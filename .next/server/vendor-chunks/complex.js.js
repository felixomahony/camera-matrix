"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/complex.js";
exports.ids = ["vendor-chunks/complex.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/complex.js/dist/complex.mjs":
/*!**************************************************!*\
  !*** ./node_modules/complex.js/dist/complex.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Complex: () => (/* binding */ Complex),\n/* harmony export */   \"default\": () => (/* binding */ Complex)\n/* harmony export */ });\n\n\n/**\n *\n * This class allows the manipulation of complex numbers.\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\n *\n * Object form\n * { re: <real>, im: <imaginary> }\n * { arg: <angle>, abs: <radius> }\n * { phi: <angle>, r: <radius> }\n *\n * Array / Vector form\n * [ real, imaginary ]\n *\n * Double form\n * 99.3 - Single double value\n *\n * String form\n * '23.1337' - Simple real number\n * '15+3i' - a simple complex number\n * '3-i' - a simple complex number\n *\n * Example:\n *\n * const c = new Complex('99.3+8i');\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\n *\n */\n\n\nconst cosh = Math.cosh || function (x) {\n  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;\n};\n\nconst sinh = Math.sinh || function (x) {\n  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;\n};\n\n/**\n * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).\n *\n * @param {number} x\n * @returns {number} cos(x) - 1\n */\nconst cosm1 = function (x) {\n\n  const b = Math.PI / 4;\n  if (-b > x || x > b) {\n    return Math.cos(x) - 1.0;\n  }\n\n  /* Calculate horner form of polynomial of taylor series in Q\n  let fac = 1, alt = 1, pol = {};\n  for (let i = 0; i <= 16; i++) {\n    fac*= i || 1;\n    if (i % 2 == 0) {\n      pol[i] = new Fraction(1, alt * fac);\n      alt = -alt;\n    }\n  }\n  console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1\n  */\n\n  const xx = x * x;\n  return xx * (\n    xx * (\n      xx * (\n        xx * (\n          xx * (\n            xx * (\n              xx * (\n                xx / 20922789888000\n                - 1 / 87178291200)\n              + 1 / 479001600)\n            - 1 / 3628800)\n          + 1 / 40320)\n        - 1 / 720)\n      + 1 / 24)\n    - 1 / 2);\n};\n\nconst hypot = function (x, y) {\n\n  x = Math.abs(x);\n  y = Math.abs(y);\n\n  // Ensure `x` is the larger value\n  if (x < y) [x, y] = [y, x];\n\n  // If both are below the threshold, use straightforward Pythagoras\n  if (x < 1e8) return Math.sqrt(x * x + y * y);\n\n  // For larger values, scale to avoid overflow\n  y /= x;\n  return x * Math.sqrt(1 + y * y);\n};\n\nconst parser_exit = function () {\n  throw SyntaxError('Invalid Param');\n};\n\n/**\n * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction logHypot(a, b) {\n\n  const _a = Math.abs(a);\n  const _b = Math.abs(b);\n\n  if (a === 0) {\n    return Math.log(_b);\n  }\n\n  if (b === 0) {\n    return Math.log(_a);\n  }\n\n  if (_a < 3000 && _b < 3000) {\n    return Math.log(a * a + b * b) * 0.5;\n  }\n\n  /* I got 4 ideas to compute this property without overflow:\n   *\n   * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\n   *\n   * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\n\n   Math.log(a * a + b * b) / 2\n\n   *\n   *\n   * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\n\n   const fn = function(a, b) {\n   a = Math.abs(a);\n   b = Math.abs(b);\n   let t = Math.min(a, b);\n   a = Math.max(a, b);\n   t = t / a;\n\n   return Math.log(a) + Math.log(1 + t * t) / 2;\n   };\n\n   * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\n\n   Math.log(a / Math.cos(Math.atan2(b, a)))\n\n   * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\n\n   Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\n\n   */\n\n  a = a * 0.5;\n  b = b * 0.5;\n\n  return 0.5 * Math.log(a * a + b * b) + Math.LN2;\n}\n\nconst P = { 're': 0, 'im': 0 };\nconst parse = function (a, b) {\n\n  const z = P;\n\n  if (a === undefined || a === null) {\n    z['re'] =\n      z['im'] = 0;\n  } else if (b !== undefined) {\n    z['re'] = a;\n    z['im'] = b;\n  } else\n    switch (typeof a) {\n\n      case 'object':\n\n        if ('im' in a && 're' in a) {\n          z['re'] = a['re'];\n          z['im'] = a['im'];\n        } else if ('abs' in a && 'arg' in a) {\n          if (!isFinite(a['abs']) && isFinite(a['arg'])) {\n            return Complex['INFINITY'];\n          }\n          z['re'] = a['abs'] * Math.cos(a['arg']);\n          z['im'] = a['abs'] * Math.sin(a['arg']);\n        } else if ('r' in a && 'phi' in a) {\n          if (!isFinite(a['r']) && isFinite(a['phi'])) {\n            return Complex['INFINITY'];\n          }\n          z['re'] = a['r'] * Math.cos(a['phi']);\n          z['im'] = a['r'] * Math.sin(a['phi']);\n        } else if (a.length === 2) { // Quick array check\n          z['re'] = a[0];\n          z['im'] = a[1];\n        } else {\n          parser_exit();\n        }\n        break;\n\n      case 'string':\n\n        z['im'] = /* void */\n        z['re'] = 0;\n\n        const tokens = a.replace(/_/g, '')\n          .match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\n        let plus = 1;\n        let minus = 0;\n\n        if (tokens === null) {\n          parser_exit();\n        }\n\n        for (let i = 0; i < tokens.length; i++) {\n\n          const c = tokens[i];\n\n          if (c === ' ' || c === '\\t' || c === '\\n') {\n            /* void */\n          } else if (c === '+') {\n            plus++;\n          } else if (c === '-') {\n            minus++;\n          } else if (c === 'i' || c === 'I') {\n\n            if (plus + minus === 0) {\n              parser_exit();\n            }\n\n            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\n              i++;\n            } else {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\n            }\n            plus = minus = 0;\n\n          } else {\n\n            if (plus + minus === 0 || isNaN(c)) {\n              parser_exit();\n            }\n\n            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\n              i++;\n            } else {\n              z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\n            }\n            plus = minus = 0;\n          }\n        }\n\n        // Still something on the stack\n        if (plus + minus > 0) {\n          parser_exit();\n        }\n        break;\n\n      case 'number':\n        z['im'] = 0;\n        z['re'] = a;\n        break;\n\n      default:\n        parser_exit();\n    }\n\n  if (isNaN(z['re']) || isNaN(z['im'])) {\n    // If a calculation is NaN, we treat it as NaN and don't throw\n    //parser_exit();\n  }\n\n  return z;\n};\n\n/**\n * @constructor\n * @returns {Complex}\n */\nfunction Complex(a, b) {\n\n  if (!(this instanceof Complex)) {\n    return new Complex(a, b);\n  }\n\n  const z = parse(a, b);\n\n  this['re'] = z['re'];\n  this['im'] = z['im'];\n}\n\nComplex.prototype = {\n\n  're': 0,\n  'im': 0,\n\n  /**\n   * Calculates the sign of a complex number, which is a normalized complex\n   *\n   * @returns {Complex}\n   */\n  'sign': function () {\n\n    const abs = hypot(this['re'], this['im']);\n\n    return new Complex(\n      this['re'] / abs,\n      this['im'] / abs);\n  },\n\n  /**\n   * Adds two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'add': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n\n    if (tInfin || zInfin) {\n\n      if (tInfin && zInfin) {\n        // Infinity + Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity + z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n\n    return new Complex(\n      this['re'] + z['re'],\n      this['im'] + z['im']);\n  },\n\n  /**\n   * Subtracts two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'sub': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n\n    if (tInfin || zInfin) {\n\n      if (tInfin && zInfin) {\n        // Infinity - Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity - z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n\n    return new Complex(\n      this['re'] - z['re'],\n      this['im'] - z['im']);\n  },\n\n  /**\n   * Multiplies two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'mul': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // Infinity * 0 = NaN\n    if (tInfin && zIsZero || zInfin && tIsZero) {\n      return Complex['NAN'];\n    }\n\n    // Infinity * z = Infinity { where z != 0 }\n    if (tInfin || zInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // Shortcut for real values\n    if (z['im'] === 0 && this['im'] === 0) {\n      return new Complex(this['re'] * z['re'], 0);\n    }\n\n    return new Complex(\n      this['re'] * z['re'] - this['im'] * z['im'],\n      this['re'] * z['im'] + this['im'] * z['re']);\n  },\n\n  /**\n   * Divides two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'div': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // 0 / 0 = NaN and Infinity / Infinity = NaN\n    if (tIsZero && zIsZero || tInfin && zInfin) {\n      return Complex['NAN'];\n    }\n\n    // Infinity / 0 = Infinity\n    if (zIsZero || tInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // 0 / Infinity = 0\n    if (tIsZero || zInfin) {\n      return Complex['ZERO'];\n    }\n\n    if (0 === z['im']) {\n      // Divisor is real\n      return new Complex(this['re'] / z['re'], this['im'] / z['re']);\n    }\n\n    if (Math.abs(z['re']) < Math.abs(z['im'])) {\n\n      const x = z['re'] / z['im'];\n      const t = z['re'] * x + z['im'];\n\n      return new Complex(\n        (this['re'] * x + this['im']) / t,\n        (this['im'] * x - this['re']) / t);\n\n    } else {\n\n      const x = z['im'] / z['re'];\n      const t = z['im'] * x + z['re'];\n\n      return new Complex(\n        (this['re'] + this['im'] * x) / t,\n        (this['im'] - this['re'] * x) / t);\n    }\n  },\n\n  /**\n   * Calculate the power of two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'pow': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    if (zIsZero) {\n      return Complex['ONE'];\n    }\n\n    // If the exponent is real\n    if (z['im'] === 0) {\n\n      if (this['im'] === 0 && this['re'] > 0) {\n\n        return new Complex(Math.pow(this['re'], z['re']), 0);\n\n      } else if (this['re'] === 0) { // If base is fully imaginary\n\n        switch ((z['re'] % 4 + 4) % 4) {\n          case 0:\n            return new Complex(Math.pow(this['im'], z['re']), 0);\n          case 1:\n            return new Complex(0, Math.pow(this['im'], z['re']));\n          case 2:\n            return new Complex(-Math.pow(this['im'], z['re']), 0);\n          case 3:\n            return new Complex(0, -Math.pow(this['im'], z['re']));\n        }\n      }\n    }\n\n    /* I couldn't find a good formula, so here is a derivation and optimization\n     *\n     * z_1^z_2 = (a + bi)^(c + di)\n     *         = exp((c + di) * log(a + bi)\n     *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\n     * =>...\n     * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n     * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n     *\n     * =>...\n     * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n     * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n     *\n     * =>\n     * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\n     * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\n     *\n     */\n\n    if (tIsZero && z['re'] > 0) { // Same behavior as Wolframalpha, Zero if real part is zero\n      return Complex['ZERO'];\n    }\n\n    const arg = Math.atan2(this['im'], this['re']);\n    const loh = logHypot(this['re'], this['im']);\n\n    let re = Math.exp(z['re'] * loh - z['im'] * arg);\n    let im = z['im'] * loh + z['re'] * arg;\n    return new Complex(\n      re * Math.cos(im),\n      re * Math.sin(im));\n  },\n\n  /**\n   * Calculate the complex square root\n   *\n   * @returns {Complex}\n   */\n  'sqrt': function () {\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n      // Real number case\n      if (a >= 0) {\n        return new Complex(Math.sqrt(a), 0);\n      } else {\n        return new Complex(0, Math.sqrt(-a));\n      }\n    }\n\n    const r = hypot(a, b);\n\n    let re = Math.sqrt(0.5 * (r + Math.abs(a))); // sqrt(2x) / 2 = sqrt(x / 2)\n    let im = Math.abs(b) / (2 * re);\n\n    if (a >= 0) {\n      return new Complex(re, b < 0 ? -im : im);\n    } else {\n      return new Complex(im, b < 0 ? -re : re);\n    }\n  },\n\n  /**\n   * Calculate the complex exponent\n   *\n   * @returns {Complex}\n   */\n  'exp': function () {\n\n    const er = Math.exp(this['re']);\n\n    if (this['im'] === 0) {\n      return new Complex(er, 0);\n    }\n    return new Complex(\n      er * Math.cos(this['im']),\n      er * Math.sin(this['im']));\n  },\n\n  /**\n   * Calculate the complex exponent and subtracts one.\n   *\n   * This may be more accurate than `Complex(x).exp().sub(1)` if\n   * `x` is small.\n   *\n   * @returns {Complex}\n   */\n  'expm1': function () {\n\n    /**\n     * exp(a + i*b) - 1\n     = exp(a) * (cos(b) + j*sin(b)) - 1\n     = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\n     */\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.expm1(a) * Math.cos(b) + cosm1(b),\n      Math.exp(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the natural log\n   *\n   * @returns {Complex}\n   */\n  'log': function () {\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0 && a > 0) {\n      return new Complex(Math.log(a), 0);\n    }\n\n    return new Complex(\n      logHypot(a, b),\n      Math.atan2(b, a));\n  },\n\n  /**\n   * Calculate the magnitude of the complex number\n   *\n   * @returns {number}\n   */\n  'abs': function () {\n\n    return hypot(this['re'], this['im']);\n  },\n\n  /**\n   * Calculate the angle of the complex number\n   *\n   * @returns {number}\n   */\n  'arg': function () {\n\n    return Math.atan2(this['im'], this['re']);\n  },\n\n  /**\n   * Calculate the sine of the complex number\n   *\n   * @returns {Complex}\n   */\n  'sin': function () {\n\n    // sin(z) = ( e^iz - e^-iz ) / 2i \n    //        = sin(a)cosh(b) + i cos(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.sin(a) * cosh(b),\n      Math.cos(a) * sinh(b));\n  },\n\n  /**\n   * Calculate the cosine\n   *\n   * @returns {Complex}\n   */\n  'cos': function () {\n\n    // cos(z) = ( e^iz + e^-iz ) / 2 \n    //        = cos(a)cosh(b) - i sin(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.cos(a) * cosh(b),\n      -Math.sin(a) * sinh(b));\n  },\n\n  /**\n   * Calculate the tangent\n   *\n   * @returns {Complex}\n   */\n  'tan': function () {\n\n    // tan(z) = sin(z) / cos(z) \n    //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )\n    //        = ( e^2iz - 1 ) / i( e^2iz + 1 )\n    //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) + cosh(b);\n\n    return new Complex(\n      Math.sin(a) / d,\n      sinh(b) / d);\n  },\n\n  /**\n   * Calculate the cotangent\n   *\n   * @returns {Complex}\n   */\n  'cot': function () {\n\n    // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) - cosh(b);\n\n    return new Complex(\n      -Math.sin(a) / d,\n      sinh(b) / d);\n  },\n\n  /**\n   * Calculate the secant\n   *\n   * @returns {Complex}\n   */\n  'sec': function () {\n\n    // sec(c) = 2 / (e^(ci) + e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\n\n    return new Complex(\n      Math.cos(a) * cosh(b) / d,\n      Math.sin(a) * sinh(b) / d);\n  },\n\n  /**\n   * Calculate the cosecans\n   *\n   * @returns {Complex}\n   */\n  'csc': function () {\n\n    // csc(c) = 2i / (e^(ci) - e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\n\n    return new Complex(\n      Math.sin(a) * cosh(b) / d,\n      -Math.cos(a) * sinh(b) / d);\n  },\n\n  /**\n   * Calculate the complex arcus sinus\n   *\n   * @returns {Complex}\n   */\n  'asin': function () {\n\n    // asin(c) = -i * log(ci + sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const t1 = new Complex(\n      b * b - a * a + 1,\n      -2 * a * b)['sqrt']();\n\n    const t2 = new Complex(\n      t1['re'] - b,\n      t1['im'] + a)['log']();\n\n    return new Complex(t2['im'], -t2['re']);\n  },\n\n  /**\n   * Calculate the complex arcus cosinus\n   *\n   * @returns {Complex}\n   */\n  'acos': function () {\n\n    // acos(c) = i * log(c - i * sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const t1 = new Complex(\n      b * b - a * a + 1,\n      -2 * a * b)['sqrt']();\n\n    const t2 = new Complex(\n      t1['re'] - b,\n      t1['im'] + a)['log']();\n\n    return new Complex(Math.PI / 2 - t2['im'], t2['re']);\n  },\n\n  /**\n   * Calculate the complex arcus tangent\n   *\n   * @returns {Complex}\n   */\n  'atan': function () {\n\n    // atan(c) = i / 2 log((i + x) / (i - x))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0) {\n\n      if (b === 1) {\n        return new Complex(0, Infinity);\n      }\n\n      if (b === -1) {\n        return new Complex(0, -Infinity);\n      }\n    }\n\n    const d = a * a + (1.0 - b) * (1.0 - b);\n\n    const t1 = new Complex(\n      (1 - b * b - a * a) / d,\n      -2 * a / d).log();\n\n    return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\n  },\n\n  /**\n   * Calculate the complex arcus cotangent\n   *\n   * @returns {Complex}\n   */\n  'acot': function () {\n\n    // acot(c) = i / 2 log((c - i) / (c + i))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n      return new Complex(Math.atan2(1, a), 0);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).atan()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).atan();\n  },\n\n  /**\n   * Calculate the complex arcus secant\n   *\n   * @returns {Complex}\n   */\n  'asec': function () {\n\n    // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0 && b === 0) {\n      return new Complex(0, Infinity);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).acos()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).acos();\n  },\n\n  /**\n   * Calculate the complex arcus cosecans\n   *\n   * @returns {Complex}\n   */\n  'acsc': function () {\n\n    // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0 && b === 0) {\n      return new Complex(Math.PI / 2, Infinity);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).asin()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).asin();\n  },\n\n  /**\n   * Calculate the complex sinh\n   *\n   * @returns {Complex}\n   */\n  'sinh': function () {\n\n    // sinh(c) = (e^c - e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      sinh(a) * Math.cos(b),\n      cosh(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the complex cosh\n   *\n   * @returns {Complex}\n   */\n  'cosh': function () {\n\n    // cosh(c) = (e^c + e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      cosh(a) * Math.cos(b),\n      sinh(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the complex tanh\n   *\n   * @returns {Complex}\n   */\n  'tanh': function () {\n\n    // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) + Math.cos(b);\n\n    return new Complex(\n      sinh(a) / d,\n      Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex coth\n   *\n   * @returns {Complex}\n   */\n  'coth': function () {\n\n    // coth(c) = (e^c + e^-c) / (e^c - e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) - Math.cos(b);\n\n    return new Complex(\n      sinh(a) / d,\n      -Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex coth\n   *\n   * @returns {Complex}\n   */\n  'csch': function () {\n\n    // csch(c) = 2 / (e^c - e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) - cosh(2 * a);\n\n    return new Complex(\n      -2 * sinh(a) * Math.cos(b) / d,\n      2 * cosh(a) * Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex sech\n   *\n   * @returns {Complex}\n   */\n  'sech': function () {\n\n    // sech(c) = 2 / (e^c + e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) + cosh(2 * a);\n\n    return new Complex(\n      2 * cosh(a) * Math.cos(b) / d,\n      -2 * sinh(a) * Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex asinh\n   *\n   * @returns {Complex}\n   */\n  'asinh': function () {\n\n    // asinh(c) = log(c + sqrt(c^2 + 1))\n\n    let tmp = this['im'];\n    this['im'] = -this['re'];\n    this['re'] = tmp;\n    const res = this['asin']();\n\n    this['re'] = -this['im'];\n    this['im'] = tmp;\n    tmp = res['re'];\n\n    res['re'] = -res['im'];\n    res['im'] = tmp;\n    return res;\n  },\n\n  /**\n   * Calculate the complex acosh\n   *\n   * @returns {Complex}\n   */\n  'acosh': function () {\n\n    // acosh(c) = log(c + sqrt(c^2 - 1))\n\n    const res = this['acos']();\n    if (res['im'] <= 0) {\n      const tmp = res['re'];\n      res['re'] = -res['im'];\n      res['im'] = tmp;\n    } else {\n      const tmp = res['im'];\n      res['im'] = -res['re'];\n      res['re'] = tmp;\n    }\n    return res;\n  },\n\n  /**\n   * Calculate the complex atanh\n   *\n   * @returns {Complex}\n   */\n  'atanh': function () {\n\n    // atanh(c) = log((1+c) / (1-c)) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const noIM = a > 1 && b === 0;\n    const oneMinus = 1 - a;\n    const onePlus = 1 + a;\n    const d = oneMinus * oneMinus + b * b;\n\n    const x = (d !== 0)\n      ? new Complex(\n        (onePlus * oneMinus - b * b) / d,\n        (b * oneMinus + onePlus * b) / d)\n      : new Complex(\n        (a !== -1) ? (a / 0) : 0,\n        (b !== 0) ? (b / 0) : 0);\n\n    const temp = x['re'];\n    x['re'] = logHypot(x['re'], x['im']) / 2;\n    x['im'] = Math.atan2(x['im'], temp) / 2;\n    if (noIM) {\n      x['im'] = -x['im'];\n    }\n    return x;\n  },\n\n  /**\n   * Calculate the complex acoth\n   *\n   * @returns {Complex}\n   */\n  'acoth': function () {\n\n    // acoth(c) = log((c+1) / (c-1)) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0 && b === 0) {\n      return new Complex(0, Math.PI / 2);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).atanh()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).atanh();\n  },\n\n  /**\n   * Calculate the complex acsch\n   *\n   * @returns {Complex}\n   */\n  'acsch': function () {\n\n    // acsch(c) = log((1+sqrt(1+c^2))/c)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n\n      return new Complex(\n        (a !== 0)\n          ? Math.log(a + Math.sqrt(a * a + 1))\n          : Infinity, 0);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).asinh()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).asinh();\n  },\n\n  /**\n   * Calculate the complex asech\n   *\n   * @returns {Complex}\n   */\n  'asech': function () {\n\n    // asech(c) = log((1+sqrt(1-c^2))/c)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (this['isZero']()) {\n      return Complex['INFINITY'];\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).acosh()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).acosh();\n  },\n\n  /**\n   * Calculate the complex inverse 1/z\n   *\n   * @returns {Complex}\n   */\n  'inverse': function () {\n\n    // 1 / 0 = Infinity and 1 / Infinity = 0\n    if (this['isZero']()) {\n      return Complex['INFINITY'];\n    }\n\n    if (this['isInfinite']()) {\n      return Complex['ZERO'];\n    }\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const d = a * a + b * b;\n\n    return new Complex(a / d, -b / d);\n  },\n\n  /**\n   * Returns the complex conjugate\n   *\n   * @returns {Complex}\n   */\n  'conjugate': function () {\n\n    return new Complex(this['re'], -this['im']);\n  },\n\n  /**\n   * Gets the negated complex number\n   *\n   * @returns {Complex}\n   */\n  'neg': function () {\n\n    return new Complex(-this['re'], -this['im']);\n  },\n\n  /**\n   * Ceils the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'ceil': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.ceil(this['re'] * places) / places,\n      Math.ceil(this['im'] * places) / places);\n  },\n\n  /**\n   * Floors the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'floor': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.floor(this['re'] * places) / places,\n      Math.floor(this['im'] * places) / places);\n  },\n\n  /**\n   * Ceils the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'round': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.round(this['re'] * places) / places,\n      Math.round(this['im'] * places) / places);\n  },\n\n  /**\n   * Compares two complex numbers\n   *\n   * **Note:** new Complex(Infinity).equals(Infinity) === false\n   *\n   * @returns {boolean}\n   */\n  'equals': function (a, b) {\n\n    const z = parse(a, b);\n\n    return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&\n      Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * @returns {Complex}\n   */\n  'clone': function () {\n\n    return new Complex(this['re'], this['im']);\n  },\n\n  /**\n   * Gets a string of the actual complex number\n   *\n   * @returns {string}\n   */\n  'toString': function () {\n\n    let a = this['re'];\n    let b = this['im'];\n    let ret = \"\";\n\n    if (this['isNaN']()) {\n      return 'NaN';\n    }\n\n    if (this['isInfinite']()) {\n      return 'Infinity';\n    }\n\n    if (Math.abs(a) < Complex['EPSILON']) {\n      a = 0;\n    }\n\n    if (Math.abs(b) < Complex['EPSILON']) {\n      b = 0;\n    }\n\n    // If is real number\n    if (b === 0) {\n      return ret + a;\n    }\n\n    if (a !== 0) {\n      ret += a;\n      ret += \" \";\n      if (b < 0) {\n        b = -b;\n        ret += \"-\";\n      } else {\n        ret += \"+\";\n      }\n      ret += \" \";\n    } else if (b < 0) {\n      b = -b;\n      ret += \"-\";\n    }\n\n    if (1 !== b) { // b is the absolute imaginary part\n      ret += b;\n    }\n    return ret + \"i\";\n  },\n\n  /**\n   * Returns the actual number as a vector\n   *\n   * @returns {Array}\n   */\n  'toVector': function () {\n\n    return [this['re'], this['im']];\n  },\n\n  /**\n   * Returns the actual real value of the current object\n   *\n   * @returns {number|null}\n   */\n  'valueOf': function () {\n\n    if (this['im'] === 0) {\n      return this['re'];\n    }\n    return null;\n  },\n\n  /**\n   * Determines whether a complex number is not on the Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isNaN': function () {\n    return isNaN(this['re']) || isNaN(this['im']);\n  },\n\n  /**\n   * Determines whether or not a complex number is at the zero pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isZero': function () {\n    return this['im'] === 0 && this['re'] === 0;\n  },\n\n  /**\n   * Determines whether a complex number is not at the infinity pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isFinite': function () {\n    return isFinite(this['re']) && isFinite(this['im']);\n  },\n\n  /**\n   * Determines whether or not a complex number is at the infinity pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isInfinite': function () {\n    return !this['isFinite']();\n  }\n};\n\nComplex['ZERO'] = new Complex(0, 0);\nComplex['ONE'] = new Complex(1, 0);\nComplex['I'] = new Complex(0, 1);\nComplex['PI'] = new Complex(Math.PI, 0);\nComplex['E'] = new Complex(Math.E, 0);\nComplex['INFINITY'] = new Complex(Infinity, Infinity);\nComplex['NAN'] = new Complex(NaN, NaN);\nComplex['EPSILON'] = 1e-15;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tcGxleC5qcy9kaXN0L2NvbXBsZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUSw2QkFBNkI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZlbGl4b21haG9ueS8uL25vZGVfbW9kdWxlcy9jb21wbGV4LmpzL2Rpc3QvY29tcGxleC5tanM/ZmM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3MgYWxsb3dzIHRoZSBtYW5pcHVsYXRpb24gb2YgY29tcGxleCBudW1iZXJzLlxuICogWW91IGNhbiBwYXNzIGEgY29tcGxleCBudW1iZXIgaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBvYmplY3QsIGRvdWJsZSwgc3RyaW5nIG9yIHR3byBpbnRlZ2VyIHBhcmFtZXRlcnMuXG4gKlxuICogT2JqZWN0IGZvcm1cbiAqIHsgcmU6IDxyZWFsPiwgaW06IDxpbWFnaW5hcnk+IH1cbiAqIHsgYXJnOiA8YW5nbGU+LCBhYnM6IDxyYWRpdXM+IH1cbiAqIHsgcGhpOiA8YW5nbGU+LCByOiA8cmFkaXVzPiB9XG4gKlxuICogQXJyYXkgLyBWZWN0b3IgZm9ybVxuICogWyByZWFsLCBpbWFnaW5hcnkgXVxuICpcbiAqIERvdWJsZSBmb3JtXG4gKiA5OS4zIC0gU2luZ2xlIGRvdWJsZSB2YWx1ZVxuICpcbiAqIFN0cmluZyBmb3JtXG4gKiAnMjMuMTMzNycgLSBTaW1wbGUgcmVhbCBudW1iZXJcbiAqICcxNSszaScgLSBhIHNpbXBsZSBjb21wbGV4IG51bWJlclxuICogJzMtaScgLSBhIHNpbXBsZSBjb21wbGV4IG51bWJlclxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogY29uc3QgYyA9IG5ldyBDb21wbGV4KCc5OS4zKzhpJyk7XG4gKiBjLm11bCh7cjogMywgaTogOX0pLmRpdig0LjkpLnN1YigzLCAyKTtcbiAqXG4gKi9cblxuXG5jb25zdCBjb3NoID0gTWF0aC5jb3NoIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4KSA8IDFlLTkgPyAxIC0geCA6IChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgKiAwLjU7XG59O1xuXG5jb25zdCBzaW5oID0gTWF0aC5zaW5oIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4KSA8IDFlLTkgPyB4IDogKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBjb3MoeCkgLSAxIHVzaW5nIFRheWxvciBzZXJpZXMgaWYgeCBpcyBzbWFsbCAoLcK8z4Ag4omkIHgg4omkIMK8z4ApLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb3MoeCkgLSAxXG4gKi9cbmNvbnN0IGNvc20xID0gZnVuY3Rpb24gKHgpIHtcblxuICBjb25zdCBiID0gTWF0aC5QSSAvIDQ7XG4gIGlmICgtYiA+IHggfHwgeCA+IGIpIHtcbiAgICByZXR1cm4gTWF0aC5jb3MoeCkgLSAxLjA7XG4gIH1cblxuICAvKiBDYWxjdWxhdGUgaG9ybmVyIGZvcm0gb2YgcG9seW5vbWlhbCBvZiB0YXlsb3Igc2VyaWVzIGluIFFcbiAgbGV0IGZhYyA9IDEsIGFsdCA9IDEsIHBvbCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSAxNjsgaSsrKSB7XG4gICAgZmFjKj0gaSB8fCAxO1xuICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICBwb2xbaV0gPSBuZXcgRnJhY3Rpb24oMSwgYWx0ICogZmFjKTtcbiAgICAgIGFsdCA9IC1hbHQ7XG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKG5ldyBQb2x5bm9taWFsKHBvbCkudG9Ib3JuZXIoKSk7IC8vICgoKCgoKCgxLzIwOTIyNzg5ODg4MDAweF4yLTEvODcxNzgyOTEyMDApeF4yKzEvNDc5MDAxNjAwKXheMi0xLzM2Mjg4MDApeF4yKzEvNDAzMjApeF4yLTEvNzIwKXheMisxLzI0KXheMi0xLzIpeF4yKzFcbiAgKi9cblxuICBjb25zdCB4eCA9IHggKiB4O1xuICByZXR1cm4geHggKiAoXG4gICAgeHggKiAoXG4gICAgICB4eCAqIChcbiAgICAgICAgeHggKiAoXG4gICAgICAgICAgeHggKiAoXG4gICAgICAgICAgICB4eCAqIChcbiAgICAgICAgICAgICAgeHggKiAoXG4gICAgICAgICAgICAgICAgeHggLyAyMDkyMjc4OTg4ODAwMFxuICAgICAgICAgICAgICAgIC0gMSAvIDg3MTc4MjkxMjAwKVxuICAgICAgICAgICAgICArIDEgLyA0NzkwMDE2MDApXG4gICAgICAgICAgICAtIDEgLyAzNjI4ODAwKVxuICAgICAgICAgICsgMSAvIDQwMzIwKVxuICAgICAgICAtIDEgLyA3MjApXG4gICAgICArIDEgLyAyNClcbiAgICAtIDEgLyAyKTtcbn07XG5cbmNvbnN0IGh5cG90ID0gZnVuY3Rpb24gKHgsIHkpIHtcblxuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHkgPSBNYXRoLmFicyh5KTtcblxuICAvLyBFbnN1cmUgYHhgIGlzIHRoZSBsYXJnZXIgdmFsdWVcbiAgaWYgKHggPCB5KSBbeCwgeV0gPSBbeSwgeF07XG5cbiAgLy8gSWYgYm90aCBhcmUgYmVsb3cgdGhlIHRocmVzaG9sZCwgdXNlIHN0cmFpZ2h0Zm9yd2FyZCBQeXRoYWdvcmFzXG4gIGlmICh4IDwgMWU4KSByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIC8vIEZvciBsYXJnZXIgdmFsdWVzLCBzY2FsZSB0byBhdm9pZCBvdmVyZmxvd1xuICB5IC89IHg7XG4gIHJldHVybiB4ICogTWF0aC5zcXJ0KDEgKyB5ICogeSk7XG59O1xuXG5jb25zdCBwYXJzZXJfZXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgU3ludGF4RXJyb3IoJ0ludmFsaWQgUGFyYW0nKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBsb2coc3FydChhXjIrYl4yKSkgaW4gYSB3YXkgdG8gYXZvaWQgb3ZlcmZsb3dzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBsb2dIeXBvdChhLCBiKSB7XG5cbiAgY29uc3QgX2EgPSBNYXRoLmFicyhhKTtcbiAgY29uc3QgX2IgPSBNYXRoLmFicyhiKTtcblxuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBNYXRoLmxvZyhfYik7XG4gIH1cblxuICBpZiAoYiA9PT0gMCkge1xuICAgIHJldHVybiBNYXRoLmxvZyhfYSk7XG4gIH1cblxuICBpZiAoX2EgPCAzMDAwICYmIF9iIDwgMzAwMCkge1xuICAgIHJldHVybiBNYXRoLmxvZyhhICogYSArIGIgKiBiKSAqIDAuNTtcbiAgfVxuXG4gIC8qIEkgZ290IDQgaWRlYXMgdG8gY29tcHV0ZSB0aGlzIHByb3BlcnR5IHdpdGhvdXQgb3ZlcmZsb3c6XG4gICAqXG4gICAqIFRlc3RpbmcgMTAwMDAwMCB0aW1lcyB3aXRoIHJhbmRvbSBzYW1wbGVzIGZvciBhLGIg4oiIIFsxLCAxMDAwMDAwMDAwXSBhZ2FpbnN0IGEgYmlnIGRlY2ltYWwgbGlicmFyeSB0byBnZXQgYW4gZXJyb3IgZXN0aW1hdGVcbiAgICpcbiAgICogMS4gT25seSBlbGltaW5hdGUgdGhlIHNxdWFyZSByb290OiAoT1ZFUkFMTCBFUlJPUjogMy45MTIyNDgzMDMwOTUxMTE2ZS0xMSlcblxuICAgTWF0aC5sb2coYSAqIGEgKyBiICogYikgLyAyXG5cbiAgICpcbiAgICpcbiAgICogMi4gVHJ5IHRvIHVzZSB0aGUgbm9uLW92ZXJmbG93aW5nIHB5dGhhZ29yYXM6IChPVkVSQUxMIEVSUk9SOiA4Ljg4OTc2MDAzOTIxMDE1OWUtMTApXG5cbiAgIGNvbnN0IGZuID0gZnVuY3Rpb24oYSwgYikge1xuICAgYSA9IE1hdGguYWJzKGEpO1xuICAgYiA9IE1hdGguYWJzKGIpO1xuICAgbGV0IHQgPSBNYXRoLm1pbihhLCBiKTtcbiAgIGEgPSBNYXRoLm1heChhLCBiKTtcbiAgIHQgPSB0IC8gYTtcblxuICAgcmV0dXJuIE1hdGgubG9nKGEpICsgTWF0aC5sb2coMSArIHQgKiB0KSAvIDI7XG4gICB9O1xuXG4gICAqIDMuIEFidXNlIHRoZSBpZGVudGl0eSBjb3MoYXRhbih5L3gpID0geCAvIHNxcnQoeF4yK3leMik6IChPVkVSQUxMIEVSUk9SOiAzLjQ3ODAxNzg3MzcwMzcyMDRlLTEwKVxuXG4gICBNYXRoLmxvZyhhIC8gTWF0aC5jb3MoTWF0aC5hdGFuMihiLCBhKSkpXG5cbiAgICogNC4gVXNlIDMuIGFuZCBhcHBseSBsb2cgcnVsZXM6IChPVkVSQUxMIEVSUk9SOiAxLjIwMTQwODc1MDI2MjA4OTZlLTkpXG5cbiAgIE1hdGgubG9nKGEpIC0gTWF0aC5sb2coTWF0aC5jb3MoTWF0aC5hdGFuMihiLCBhKSkpXG5cbiAgICovXG5cbiAgYSA9IGEgKiAwLjU7XG4gIGIgPSBiICogMC41O1xuXG4gIHJldHVybiAwLjUgKiBNYXRoLmxvZyhhICogYSArIGIgKiBiKSArIE1hdGguTE4yO1xufVxuXG5jb25zdCBQID0geyAncmUnOiAwLCAnaW0nOiAwIH07XG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgY29uc3QgeiA9IFA7XG5cbiAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XG4gICAgelsncmUnXSA9XG4gICAgICB6WydpbSddID0gMDtcbiAgfSBlbHNlIGlmIChiICE9PSB1bmRlZmluZWQpIHtcbiAgICB6WydyZSddID0gYTtcbiAgICB6WydpbSddID0gYjtcbiAgfSBlbHNlXG4gICAgc3dpdGNoICh0eXBlb2YgYSkge1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuXG4gICAgICAgIGlmICgnaW0nIGluIGEgJiYgJ3JlJyBpbiBhKSB7XG4gICAgICAgICAgelsncmUnXSA9IGFbJ3JlJ107XG4gICAgICAgICAgelsnaW0nXSA9IGFbJ2ltJ107XG4gICAgICAgIH0gZWxzZSBpZiAoJ2FicycgaW4gYSAmJiAnYXJnJyBpbiBhKSB7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShhWydhYnMnXSkgJiYgaXNGaW5pdGUoYVsnYXJnJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgelsncmUnXSA9IGFbJ2FicyddICogTWF0aC5jb3MoYVsnYXJnJ10pO1xuICAgICAgICAgIHpbJ2ltJ10gPSBhWydhYnMnXSAqIE1hdGguc2luKGFbJ2FyZyddKTtcbiAgICAgICAgfSBlbHNlIGlmICgncicgaW4gYSAmJiAncGhpJyBpbiBhKSB7XG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShhWydyJ10pICYmIGlzRmluaXRlKGFbJ3BoaSddKSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBsZXhbJ0lORklOSVRZJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIHpbJ3JlJ10gPSBhWydyJ10gKiBNYXRoLmNvcyhhWydwaGknXSk7XG4gICAgICAgICAgelsnaW0nXSA9IGFbJ3InXSAqIE1hdGguc2luKGFbJ3BoaSddKTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmxlbmd0aCA9PT0gMikgeyAvLyBRdWljayBhcnJheSBjaGVja1xuICAgICAgICAgIHpbJ3JlJ10gPSBhWzBdO1xuICAgICAgICAgIHpbJ2ltJ10gPSBhWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG5cbiAgICAgICAgelsnaW0nXSA9IC8qIHZvaWQgKi9cbiAgICAgICAgelsncmUnXSA9IDA7XG5cbiAgICAgICAgY29uc3QgdG9rZW5zID0gYS5yZXBsYWNlKC9fL2csICcnKVxuICAgICAgICAgIC5tYXRjaCgvXFxkK1xcLj9cXGQqZVsrLV0/XFxkK3xcXGQrXFwuP1xcZCp8XFwuXFxkK3wuL2cpO1xuICAgICAgICBsZXQgcGx1cyA9IDE7XG4gICAgICAgIGxldCBtaW51cyA9IDA7XG5cbiAgICAgICAgaWYgKHRva2VucyA9PT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgY29uc3QgYyA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgIGlmIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8qIHZvaWQgKi9cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcrJykge1xuICAgICAgICAgICAgcGx1cysrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBtaW51cysrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ2knIHx8IGMgPT09ICdJJykge1xuXG4gICAgICAgICAgICBpZiAocGx1cyArIG1pbnVzID09PSAwKSB7XG4gICAgICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnNbaSArIDFdICE9PSAnICcgJiYgIWlzTmFOKHRva2Vuc1tpICsgMV0pKSB7XG4gICAgICAgICAgICAgIHpbJ2ltJ10gKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gJy0nIDogJycpICsgdG9rZW5zW2kgKyAxXSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHpbJ2ltJ10gKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gJy0nIDogJycpICsgJzEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsdXMgPSBtaW51cyA9IDA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAocGx1cyArIG1pbnVzID09PSAwIHx8IGlzTmFOKGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnNbaSArIDFdID09PSAnaScgfHwgdG9rZW5zW2kgKyAxXSA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgIHpbJ2ltJ10gKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gJy0nIDogJycpICsgYyk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHpbJ3JlJ10gKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gJy0nIDogJycpICsgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbHVzID0gbWludXMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0aWxsIHNvbWV0aGluZyBvbiB0aGUgc3RhY2tcbiAgICAgICAgaWYgKHBsdXMgKyBtaW51cyA+IDApIHtcbiAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICB6WydpbSddID0gMDtcbiAgICAgICAgelsncmUnXSA9IGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgIH1cblxuICBpZiAoaXNOYU4oelsncmUnXSkgfHwgaXNOYU4oelsnaW0nXSkpIHtcbiAgICAvLyBJZiBhIGNhbGN1bGF0aW9uIGlzIE5hTiwgd2UgdHJlYXQgaXQgYXMgTmFOIGFuZCBkb24ndCB0aHJvd1xuICAgIC8vcGFyc2VyX2V4aXQoKTtcbiAgfVxuXG4gIHJldHVybiB6O1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEByZXR1cm5zIHtDb21wbGV4fVxuICovXG5mdW5jdGlvbiBDb21wbGV4KGEsIGIpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGxleCkpIHtcbiAgICByZXR1cm4gbmV3IENvbXBsZXgoYSwgYik7XG4gIH1cblxuICBjb25zdCB6ID0gcGFyc2UoYSwgYik7XG5cbiAgdGhpc1sncmUnXSA9IHpbJ3JlJ107XG4gIHRoaXNbJ2ltJ10gPSB6WydpbSddO1xufVxuXG5Db21wbGV4LnByb3RvdHlwZSA9IHtcblxuICAncmUnOiAwLFxuICAnaW0nOiAwLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzaWduIG9mIGEgY29tcGxleCBudW1iZXIsIHdoaWNoIGlzIGEgbm9ybWFsaXplZCBjb21wbGV4XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3NpZ24nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBhYnMgPSBoeXBvdCh0aGlzWydyZSddLCB0aGlzWydpbSddKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIHRoaXNbJ3JlJ10gLyBhYnMsXG4gICAgICB0aGlzWydpbSddIC8gYWJzKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2FkZCc6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBjb25zdCB6ID0gcGFyc2UoYSwgYik7XG5cbiAgICBjb25zdCB0SW5maW4gPSB0aGlzWydpc0luZmluaXRlJ10oKTtcbiAgICBjb25zdCB6SW5maW4gPSAhKGlzRmluaXRlKHpbJ3JlJ10pICYmIGlzRmluaXRlKHpbJ2ltJ10pKTtcblxuICAgIGlmICh0SW5maW4gfHwgekluZmluKSB7XG5cbiAgICAgIGlmICh0SW5maW4gJiYgekluZmluKSB7XG4gICAgICAgIC8vIEluZmluaXR5ICsgSW5maW5pdHkgPSBOYU5cbiAgICAgICAgcmV0dXJuIENvbXBsZXhbJ05BTiddO1xuICAgICAgfVxuICAgICAgLy8gSW5maW5pdHkgKyB6ID0gSW5maW5pdHkgeyB3aGVyZSB6ICE9IEluZmluaXR5IH1cbiAgICAgIHJldHVybiBDb21wbGV4WydJTkZJTklUWSddO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIHRoaXNbJ3JlJ10gKyB6WydyZSddLFxuICAgICAgdGhpc1snaW0nXSArIHpbJ2ltJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdzdWInOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gICAgY29uc3QgdEluZmluID0gdGhpc1snaXNJbmZpbml0ZSddKCk7XG4gICAgY29uc3QgekluZmluID0gIShpc0Zpbml0ZSh6WydyZSddKSAmJiBpc0Zpbml0ZSh6WydpbSddKSk7XG5cbiAgICBpZiAodEluZmluIHx8IHpJbmZpbikge1xuXG4gICAgICBpZiAodEluZmluICYmIHpJbmZpbikge1xuICAgICAgICAvLyBJbmZpbml0eSAtIEluZmluaXR5ID0gTmFOXG4gICAgICAgIHJldHVybiBDb21wbGV4WydOQU4nXTtcbiAgICAgIH1cbiAgICAgIC8vIEluZmluaXR5IC0geiA9IEluZmluaXR5IHsgd2hlcmUgeiAhPSBJbmZpbml0eSB9XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICB0aGlzWydyZSddIC0gelsncmUnXSxcbiAgICAgIHRoaXNbJ2ltJ10gLSB6WydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ211bCc6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBjb25zdCB6ID0gcGFyc2UoYSwgYik7XG5cbiAgICBjb25zdCB0SW5maW4gPSB0aGlzWydpc0luZmluaXRlJ10oKTtcbiAgICBjb25zdCB6SW5maW4gPSAhKGlzRmluaXRlKHpbJ3JlJ10pICYmIGlzRmluaXRlKHpbJ2ltJ10pKTtcbiAgICBjb25zdCB0SXNaZXJvID0gdGhpc1sncmUnXSA9PT0gMCAmJiB0aGlzWydpbSddID09PSAwO1xuICAgIGNvbnN0IHpJc1plcm8gPSB6WydyZSddID09PSAwICYmIHpbJ2ltJ10gPT09IDA7XG5cbiAgICAvLyBJbmZpbml0eSAqIDAgPSBOYU5cbiAgICBpZiAodEluZmluICYmIHpJc1plcm8gfHwgekluZmluICYmIHRJc1plcm8pIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydOQU4nXTtcbiAgICB9XG5cbiAgICAvLyBJbmZpbml0eSAqIHogPSBJbmZpbml0eSB7IHdoZXJlIHogIT0gMCB9XG4gICAgaWYgKHRJbmZpbiB8fCB6SW5maW4pIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydJTkZJTklUWSddO1xuICAgIH1cblxuICAgIC8vIFNob3J0Y3V0IGZvciByZWFsIHZhbHVlc1xuICAgIGlmICh6WydpbSddID09PSAwICYmIHRoaXNbJ2ltJ10gPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzWydyZSddICogelsncmUnXSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgdGhpc1sncmUnXSAqIHpbJ3JlJ10gLSB0aGlzWydpbSddICogelsnaW0nXSxcbiAgICAgIHRoaXNbJ3JlJ10gKiB6WydpbSddICsgdGhpc1snaW0nXSAqIHpbJ3JlJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnZGl2JzogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IHogPSBwYXJzZShhLCBiKTtcblxuICAgIGNvbnN0IHRJbmZpbiA9IHRoaXNbJ2lzSW5maW5pdGUnXSgpO1xuICAgIGNvbnN0IHpJbmZpbiA9ICEoaXNGaW5pdGUoelsncmUnXSkgJiYgaXNGaW5pdGUoelsnaW0nXSkpO1xuICAgIGNvbnN0IHRJc1plcm8gPSB0aGlzWydyZSddID09PSAwICYmIHRoaXNbJ2ltJ10gPT09IDA7XG4gICAgY29uc3QgeklzWmVybyA9IHpbJ3JlJ10gPT09IDAgJiYgelsnaW0nXSA9PT0gMDtcblxuICAgIC8vIDAgLyAwID0gTmFOIGFuZCBJbmZpbml0eSAvIEluZmluaXR5ID0gTmFOXG4gICAgaWYgKHRJc1plcm8gJiYgeklzWmVybyB8fCB0SW5maW4gJiYgekluZmluKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnTkFOJ107XG4gICAgfVxuXG4gICAgLy8gSW5maW5pdHkgLyAwID0gSW5maW5pdHlcbiAgICBpZiAoeklzWmVybyB8fCB0SW5maW4pIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydJTkZJTklUWSddO1xuICAgIH1cblxuICAgIC8vIDAgLyBJbmZpbml0eSA9IDBcbiAgICBpZiAodElzWmVybyB8fCB6SW5maW4pIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydaRVJPJ107XG4gICAgfVxuXG4gICAgaWYgKDAgPT09IHpbJ2ltJ10pIHtcbiAgICAgIC8vIERpdmlzb3IgaXMgcmVhbFxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHRoaXNbJ3JlJ10gLyB6WydyZSddLCB0aGlzWydpbSddIC8gelsncmUnXSk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHpbJ3JlJ10pIDwgTWF0aC5hYnMoelsnaW0nXSkpIHtcblxuICAgICAgY29uc3QgeCA9IHpbJ3JlJ10gLyB6WydpbSddO1xuICAgICAgY29uc3QgdCA9IHpbJ3JlJ10gKiB4ICsgelsnaW0nXTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAodGhpc1sncmUnXSAqIHggKyB0aGlzWydpbSddKSAvIHQsXG4gICAgICAgICh0aGlzWydpbSddICogeCAtIHRoaXNbJ3JlJ10pIC8gdCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zdCB4ID0gelsnaW0nXSAvIHpbJ3JlJ107XG4gICAgICBjb25zdCB0ID0gelsnaW0nXSAqIHggKyB6WydyZSddO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICh0aGlzWydyZSddICsgdGhpc1snaW0nXSAqIHgpIC8gdCxcbiAgICAgICAgKHRoaXNbJ2ltJ10gLSB0aGlzWydyZSddICogeCkgLyB0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdwb3cnOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gICAgY29uc3QgdElzWmVybyA9IHRoaXNbJ3JlJ10gPT09IDAgJiYgdGhpc1snaW0nXSA9PT0gMDtcbiAgICBjb25zdCB6SXNaZXJvID0gelsncmUnXSA9PT0gMCAmJiB6WydpbSddID09PSAwO1xuXG4gICAgaWYgKHpJc1plcm8pIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydPTkUnXTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZXhwb25lbnQgaXMgcmVhbFxuICAgIGlmICh6WydpbSddID09PSAwKSB7XG5cbiAgICAgIGlmICh0aGlzWydpbSddID09PSAwICYmIHRoaXNbJ3JlJ10gPiAwKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGgucG93KHRoaXNbJ3JlJ10sIHpbJ3JlJ10pLCAwKTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzWydyZSddID09PSAwKSB7IC8vIElmIGJhc2UgaXMgZnVsbHkgaW1hZ2luYXJ5XG5cbiAgICAgICAgc3dpdGNoICgoelsncmUnXSAlIDQgKyA0KSAlIDQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5wb3codGhpc1snaW0nXSwgelsncmUnXSksIDApO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBNYXRoLnBvdyh0aGlzWydpbSddLCB6WydyZSddKSk7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC1NYXRoLnBvdyh0aGlzWydpbSddLCB6WydyZSddKSwgMCk7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIC1NYXRoLnBvdyh0aGlzWydpbSddLCB6WydyZSddKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJIGNvdWxkbid0IGZpbmQgYSBnb29kIGZvcm11bGEsIHNvIGhlcmUgaXMgYSBkZXJpdmF0aW9uIGFuZCBvcHRpbWl6YXRpb25cbiAgICAgKlxuICAgICAqIHpfMV56XzIgPSAoYSArIGJpKV4oYyArIGRpKVxuICAgICAqICAgICAgICAgPSBleHAoKGMgKyBkaSkgKiBsb2coYSArIGJpKVxuICAgICAqICAgICAgICAgPSBwb3coYV4yICsgYl4yLCAoYyArIGRpKSAvIDIpICogZXhwKGkoYyArIGRpKWF0YW4yKGIsIGEpKVxuICAgICAqID0+Li4uXG4gICAgICogUmUgPSAocG93KGFeMiArIGJeMiwgYyAvIDIpICogZXhwKC1kICogYXRhbjIoYiwgYSkpKSAqIGNvcyhkICogbG9nKGFeMiArIGJeMikgLyAyICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAqIEltID0gKHBvdyhhXjIgKyBiXjIsIGMgLyAyKSAqIGV4cCgtZCAqIGF0YW4yKGIsIGEpKSkgKiBzaW4oZCAqIGxvZyhhXjIgKyBiXjIpIC8gMiArIGMgKiBhdGFuMihiLCBhKSlcbiAgICAgKlxuICAgICAqID0+Li4uXG4gICAgICogUmUgPSBleHAoYyAqIGxvZyhzcXJ0KGFeMiArIGJeMikpIC0gZCAqIGF0YW4yKGIsIGEpKSAqIGNvcyhkICogbG9nKHNxcnQoYV4yICsgYl4yKSkgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICogSW0gPSBleHAoYyAqIGxvZyhzcXJ0KGFeMiArIGJeMikpIC0gZCAqIGF0YW4yKGIsIGEpKSAqIHNpbihkICogbG9nKHNxcnQoYV4yICsgYl4yKSkgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICpcbiAgICAgKiA9PlxuICAgICAqIFJlID0gZXhwKGMgKiBsb2dzcTIgLSBkICogYXJnKHpfMSkpICogY29zKGQgKiBsb2dzcTIgKyBjICogYXJnKHpfMSkpXG4gICAgICogSW0gPSBleHAoYyAqIGxvZ3NxMiAtIGQgKiBhcmcoel8xKSkgKiBzaW4oZCAqIGxvZ3NxMiArIGMgKiBhcmcoel8xKSlcbiAgICAgKlxuICAgICAqL1xuXG4gICAgaWYgKHRJc1plcm8gJiYgelsncmUnXSA+IDApIHsgLy8gU2FtZSBiZWhhdmlvciBhcyBXb2xmcmFtYWxwaGEsIFplcm8gaWYgcmVhbCBwYXJ0IGlzIHplcm9cbiAgICAgIHJldHVybiBDb21wbGV4WydaRVJPJ107XG4gICAgfVxuXG4gICAgY29uc3QgYXJnID0gTWF0aC5hdGFuMih0aGlzWydpbSddLCB0aGlzWydyZSddKTtcbiAgICBjb25zdCBsb2ggPSBsb2dIeXBvdCh0aGlzWydyZSddLCB0aGlzWydpbSddKTtcblxuICAgIGxldCByZSA9IE1hdGguZXhwKHpbJ3JlJ10gKiBsb2ggLSB6WydpbSddICogYXJnKTtcbiAgICBsZXQgaW0gPSB6WydpbSddICogbG9oICsgelsncmUnXSAqIGFyZztcbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICByZSAqIE1hdGguY29zKGltKSxcbiAgICAgIHJlICogTWF0aC5zaW4oaW0pKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNxdWFyZSByb290XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3NxcnQnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICAvLyBSZWFsIG51bWJlciBjYXNlXG4gICAgICBpZiAoYSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLnNxcnQoYSksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIE1hdGguc3FydCgtYSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHIgPSBoeXBvdChhLCBiKTtcblxuICAgIGxldCByZSA9IE1hdGguc3FydCgwLjUgKiAociArIE1hdGguYWJzKGEpKSk7IC8vIHNxcnQoMngpIC8gMiA9IHNxcnQoeCAvIDIpXG4gICAgbGV0IGltID0gTWF0aC5hYnMoYikgLyAoMiAqIHJlKTtcblxuICAgIGlmIChhID49IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChyZSwgYiA8IDAgPyAtaW0gOiBpbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChpbSwgYiA8IDAgPyAtcmUgOiByZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggZXhwb25lbnRcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnZXhwJzogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgZXIgPSBNYXRoLmV4cCh0aGlzWydyZSddKTtcblxuICAgIGlmICh0aGlzWydpbSddID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoZXIsIDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBlciAqIE1hdGguY29zKHRoaXNbJ2ltJ10pLFxuICAgICAgZXIgKiBNYXRoLnNpbih0aGlzWydpbSddKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBleHBvbmVudCBhbmQgc3VidHJhY3RzIG9uZS5cbiAgICpcbiAgICogVGhpcyBtYXkgYmUgbW9yZSBhY2N1cmF0ZSB0aGFuIGBDb21wbGV4KHgpLmV4cCgpLnN1YigxKWAgaWZcbiAgICogYHhgIGlzIHNtYWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdleHBtMSc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIGV4cChhICsgaSpiKSAtIDFcbiAgICAgPSBleHAoYSkgKiAoY29zKGIpICsgaipzaW4oYikpIC0gMVxuICAgICA9IGV4cG0xKGEpKmNvcyhiKSArIGNvc20xKGIpICsgaipleHAoYSkqc2luKGIpXG4gICAgICovXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguZXhwbTEoYSkgKiBNYXRoLmNvcyhiKSArIGNvc20xKGIpLFxuICAgICAgTWF0aC5leHAoYSkgKiBNYXRoLnNpbihiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbmF0dXJhbCBsb2dcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnbG9nJzogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYiA9PT0gMCAmJiBhID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGgubG9nKGEpLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBsb2dIeXBvdChhLCBiKSxcbiAgICAgIE1hdGguYXRhbjIoYiwgYSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG1hZ25pdHVkZSBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gICdhYnMnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gaHlwb3QodGhpc1sncmUnXSwgdGhpc1snaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgYW5nbGUgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICAnYXJnJzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbjIodGhpc1snaW0nXSwgdGhpc1sncmUnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2luZSBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnc2luJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gc2luKHopID0gKCBlXml6IC0gZV4taXogKSAvIDJpIFxuICAgIC8vICAgICAgICA9IHNpbihhKWNvc2goYikgKyBpIGNvcyhhKXNpbmgoYilcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgTWF0aC5zaW4oYSkgKiBjb3NoKGIpLFxuICAgICAgTWF0aC5jb3MoYSkgKiBzaW5oKGIpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb3NpbmVcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY29zJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY29zKHopID0gKCBlXml6ICsgZV4taXogKSAvIDIgXG4gICAgLy8gICAgICAgID0gY29zKGEpY29zaChiKSAtIGkgc2luKGEpc2luaChiKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLmNvcyhhKSAqIGNvc2goYiksXG4gICAgICAtTWF0aC5zaW4oYSkgKiBzaW5oKGIpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0YW5nZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3Rhbic6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHRhbih6KSA9IHNpbih6KSAvIGNvcyh6KSBcbiAgICAvLyAgICAgICAgPSAoIGVeaXogLSBlXi1peiApIC8gKCBpKCBlXml6ICsgZV4taXogKSApXG4gICAgLy8gICAgICAgID0gKCBlXjJpeiAtIDEgKSAvIGkoIGVeMml6ICsgMSApXG4gICAgLy8gICAgICAgID0gKCBzaW4oMmEpICsgaSBzaW5oKDJiKSApIC8gKCBjb3MoMmEpICsgY29zaCgyYikgKVxuXG4gICAgY29uc3QgYSA9IDIgKiB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSAyICogdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gTWF0aC5jb3MoYSkgKyBjb3NoKGIpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgTWF0aC5zaW4oYSkgLyBkLFxuICAgICAgc2luaChiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvdGFuZ2VudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdjb3QnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBjb3QoYykgPSBpKGVeKGNpKSArIGVeKC1jaSkpIC8gKGVeKGNpKSAtIGVeKC1jaSkpXG5cbiAgICBjb25zdCBhID0gMiAqIHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IDIgKiB0aGlzWydpbSddO1xuICAgIGNvbnN0IGQgPSBNYXRoLmNvcyhhKSAtIGNvc2goYik7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAtTWF0aC5zaW4oYSkgLyBkLFxuICAgICAgc2luaChiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNlY2FudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdzZWMnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBzZWMoYykgPSAyIC8gKGVeKGNpKSArIGVeKC1jaSkpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gMC41ICogY29zaCgyICogYikgKyAwLjUgKiBNYXRoLmNvcygyICogYSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLmNvcyhhKSAqIGNvc2goYikgLyBkLFxuICAgICAgTWF0aC5zaW4oYSkgKiBzaW5oKGIpIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29zZWNhbnNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY3NjJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY3NjKGMpID0gMmkgLyAoZV4oY2kpIC0gZV4oLWNpKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuICAgIGNvbnN0IGQgPSAwLjUgKiBjb3NoKDIgKiBiKSAtIDAuNSAqIE1hdGguY29zKDIgKiBhKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguc2luKGEpICogY29zaChiKSAvIGQsXG4gICAgICAtTWF0aC5jb3MoYSkgKiBzaW5oKGIpIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBzaW51c1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhc2luJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYXNpbihjKSA9IC1pICogbG9nKGNpICsgc3FydCgxIC0gY14yKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgY29uc3QgdDEgPSBuZXcgQ29tcGxleChcbiAgICAgIGIgKiBiIC0gYSAqIGEgKyAxLFxuICAgICAgLTIgKiBhICogYilbJ3NxcnQnXSgpO1xuXG4gICAgY29uc3QgdDIgPSBuZXcgQ29tcGxleChcbiAgICAgIHQxWydyZSddIC0gYixcbiAgICAgIHQxWydpbSddICsgYSlbJ2xvZyddKCk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgodDJbJ2ltJ10sIC10MlsncmUnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBjb3NpbnVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Fjb3MnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhY29zKGMpID0gaSAqIGxvZyhjIC0gaSAqIHNxcnQoMSAtIGNeMikpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGNvbnN0IHQxID0gbmV3IENvbXBsZXgoXG4gICAgICBiICogYiAtIGEgKiBhICsgMSxcbiAgICAgIC0yICogYSAqIGIpWydzcXJ0J10oKTtcblxuICAgIGNvbnN0IHQyID0gbmV3IENvbXBsZXgoXG4gICAgICB0MVsncmUnXSAtIGIsXG4gICAgICB0MVsnaW0nXSArIGEpWydsb2cnXSgpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGguUEkgLyAyIC0gdDJbJ2ltJ10sIHQyWydyZSddKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIHRhbmdlbnRcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYXRhbic6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGF0YW4oYykgPSBpIC8gMiBsb2coKGkgKyB4KSAvIChpIC0geCkpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChhID09PSAwKSB7XG5cbiAgICAgIGlmIChiID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBJbmZpbml0eSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgLUluZmluaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyAoMS4wIC0gYikgKiAoMS4wIC0gYik7XG5cbiAgICBjb25zdCB0MSA9IG5ldyBDb21wbGV4KFxuICAgICAgKDEgLSBiICogYiAtIGEgKiBhKSAvIGQsXG4gICAgICAtMiAqIGEgLyBkKS5sb2coKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleCgtMC41ICogdDFbJ2ltJ10sIDAuNSAqIHQxWydyZSddKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIGNvdGFuZ2VudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhY290JzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYWNvdChjKSA9IGkgLyAyIGxvZygoYyAtIGkpIC8gKGMgKyBpKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGIgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLmF0YW4yKDEsIGEpLCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcbiAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICBhIC8gZCxcbiAgICAgICAgLWIgLyBkKS5hdGFuKClcbiAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgKGIgIT09IDApID8gLWIgLyAwIDogMCkuYXRhbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgc2VjYW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2FzZWMnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhc2VjKGMpID0gLWkgKiBsb2coMSAvIGMgKyBzcXJ0KDEgLSBpIC8gY14yKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIEluZmluaXR5KTtcbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcbiAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICBhIC8gZCxcbiAgICAgICAgLWIgLyBkKS5hY29zKClcbiAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgKGIgIT09IDApID8gLWIgLyAwIDogMCkuYWNvcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgY29zZWNhbnNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYWNzYyc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFjc2MoYykgPSAtaSAqIGxvZyhpIC8gYyArIHNxcnQoMSAtIDEgLyBjXjIpKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5QSSAvIDIsIEluZmluaXR5KTtcbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcbiAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICBhIC8gZCxcbiAgICAgICAgLWIgLyBkKS5hc2luKClcbiAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgKGIgIT09IDApID8gLWIgLyAwIDogMCkuYXNpbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggc2luaFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdzaW5oJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gc2luaChjKSA9IChlXmMgLSBlXi1jKSAvIDJcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgc2luaChhKSAqIE1hdGguY29zKGIpLFxuICAgICAgY29zaChhKSAqIE1hdGguc2luKGIpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGNvc2hcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY29zaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGNvc2goYykgPSAoZV5jICsgZV4tYykgLyAyXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIGNvc2goYSkgKiBNYXRoLmNvcyhiKSxcbiAgICAgIHNpbmgoYSkgKiBNYXRoLnNpbihiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCB0YW5oXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3RhbmgnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyB0YW5oKGMpID0gKGVeYyAtIGVeLWMpIC8gKGVeYyArIGVeLWMpXG5cbiAgICBjb25zdCBhID0gMiAqIHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IDIgKiB0aGlzWydpbSddO1xuICAgIGNvbnN0IGQgPSBjb3NoKGEpICsgTWF0aC5jb3MoYik7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBzaW5oKGEpIC8gZCxcbiAgICAgIE1hdGguc2luKGIpIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBjb3RoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2NvdGgnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBjb3RoKGMpID0gKGVeYyArIGVeLWMpIC8gKGVeYyAtIGVeLWMpXG5cbiAgICBjb25zdCBhID0gMiAqIHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IDIgKiB0aGlzWydpbSddO1xuICAgIGNvbnN0IGQgPSBjb3NoKGEpIC0gTWF0aC5jb3MoYik7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBzaW5oKGEpIC8gZCxcbiAgICAgIC1NYXRoLnNpbihiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggY290aFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdjc2NoJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY3NjaChjKSA9IDIgLyAoZV5jIC0gZV4tYylcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuICAgIGNvbnN0IGQgPSBNYXRoLmNvcygyICogYikgLSBjb3NoKDIgKiBhKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIC0yICogc2luaChhKSAqIE1hdGguY29zKGIpIC8gZCxcbiAgICAgIDIgKiBjb3NoKGEpICogTWF0aC5zaW4oYikgLyBkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNlY2hcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnc2VjaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHNlY2goYykgPSAyIC8gKGVeYyArIGVeLWMpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gTWF0aC5jb3MoMiAqIGIpICsgY29zaCgyICogYSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAyICogY29zaChhKSAqIE1hdGguY29zKGIpIC8gZCxcbiAgICAgIC0yICogc2luaChhKSAqIE1hdGguc2luKGIpIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhc2luaFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhc2luaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFzaW5oKGMpID0gbG9nKGMgKyBzcXJ0KGNeMiArIDEpKVxuXG4gICAgbGV0IHRtcCA9IHRoaXNbJ2ltJ107XG4gICAgdGhpc1snaW0nXSA9IC10aGlzWydyZSddO1xuICAgIHRoaXNbJ3JlJ10gPSB0bXA7XG4gICAgY29uc3QgcmVzID0gdGhpc1snYXNpbiddKCk7XG5cbiAgICB0aGlzWydyZSddID0gLXRoaXNbJ2ltJ107XG4gICAgdGhpc1snaW0nXSA9IHRtcDtcbiAgICB0bXAgPSByZXNbJ3JlJ107XG5cbiAgICByZXNbJ3JlJ10gPSAtcmVzWydpbSddO1xuICAgIHJlc1snaW0nXSA9IHRtcDtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYWNvc2hcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYWNvc2gnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhY29zaChjKSA9IGxvZyhjICsgc3FydChjXjIgLSAxKSlcblxuICAgIGNvbnN0IHJlcyA9IHRoaXNbJ2Fjb3MnXSgpO1xuICAgIGlmIChyZXNbJ2ltJ10gPD0gMCkge1xuICAgICAgY29uc3QgdG1wID0gcmVzWydyZSddO1xuICAgICAgcmVzWydyZSddID0gLXJlc1snaW0nXTtcbiAgICAgIHJlc1snaW0nXSA9IHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wID0gcmVzWydpbSddO1xuICAgICAgcmVzWydpbSddID0gLXJlc1sncmUnXTtcbiAgICAgIHJlc1sncmUnXSA9IHRtcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGF0YW5oXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2F0YW5oJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYXRhbmgoYykgPSBsb2coKDErYykgLyAoMS1jKSkgLyAyXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGNvbnN0IG5vSU0gPSBhID4gMSAmJiBiID09PSAwO1xuICAgIGNvbnN0IG9uZU1pbnVzID0gMSAtIGE7XG4gICAgY29uc3Qgb25lUGx1cyA9IDEgKyBhO1xuICAgIGNvbnN0IGQgPSBvbmVNaW51cyAqIG9uZU1pbnVzICsgYiAqIGI7XG5cbiAgICBjb25zdCB4ID0gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAob25lUGx1cyAqIG9uZU1pbnVzIC0gYiAqIGIpIC8gZCxcbiAgICAgICAgKGIgKiBvbmVNaW51cyArIG9uZVBsdXMgKiBiKSAvIGQpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gLTEpID8gKGEgLyAwKSA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IChiIC8gMCkgOiAwKTtcblxuICAgIGNvbnN0IHRlbXAgPSB4WydyZSddO1xuICAgIHhbJ3JlJ10gPSBsb2dIeXBvdCh4WydyZSddLCB4WydpbSddKSAvIDI7XG4gICAgeFsnaW0nXSA9IE1hdGguYXRhbjIoeFsnaW0nXSwgdGVtcCkgLyAyO1xuICAgIGlmIChub0lNKSB7XG4gICAgICB4WydpbSddID0gLXhbJ2ltJ107XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYWNvdGhcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYWNvdGgnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhY290aChjKSA9IGxvZygoYysxKSAvIChjLTEpKSAvIDJcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIE1hdGguUEkgLyAyKTtcbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcbiAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICBhIC8gZCxcbiAgICAgICAgLWIgLyBkKS5hdGFuaCgpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IC1iIC8gMCA6IDApLmF0YW5oKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhY3NjaFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhY3NjaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFjc2NoKGMpID0gbG9nKCgxK3NxcnQoMStjXjIpKS9jKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYiA9PT0gMCkge1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgIChhICE9PSAwKVxuICAgICAgICAgID8gTWF0aC5sb2coYSArIE1hdGguc3FydChhICogYSArIDEpKVxuICAgICAgICAgIDogSW5maW5pdHksIDApO1xuICAgIH1cblxuICAgIGNvbnN0IGQgPSBhICogYSArIGIgKiBiO1xuICAgIHJldHVybiAoZCAhPT0gMClcbiAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgIGEgLyBkLFxuICAgICAgICAtYiAvIGQpLmFzaW5oKClcbiAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgKGIgIT09IDApID8gLWIgLyAwIDogMCkuYXNpbmgoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFzZWNoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2FzZWNoJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYXNlY2goYykgPSBsb2coKDErc3FydCgxLWNeMikpL2MpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmICh0aGlzWydpc1plcm8nXSgpKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcbiAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICBhIC8gZCxcbiAgICAgICAgLWIgLyBkKS5hY29zaCgpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IC1iIC8gMCA6IDApLmFjb3NoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBpbnZlcnNlIDEvelxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdpbnZlcnNlJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gMSAvIDAgPSBJbmZpbml0eSBhbmQgMSAvIEluZmluaXR5ID0gMFxuICAgIGlmICh0aGlzWydpc1plcm8nXSgpKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1snaXNJbmZpbml0ZSddKCkpIHtcbiAgICAgIHJldHVybiBDb21wbGV4WydaRVJPJ107XG4gICAgfVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBjb25zdCBkID0gYSAqIGEgKyBiICogYjtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChhIC8gZCwgLWIgLyBkKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcGxleCBjb25qdWdhdGVcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY29uanVnYXRlJzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KHRoaXNbJ3JlJ10sIC10aGlzWydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbmVnYXRlZCBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICduZWcnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoLXRoaXNbJ3JlJ10sIC10aGlzWydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2VpbHMgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdjZWlsJzogZnVuY3Rpb24gKHBsYWNlcykge1xuXG4gICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguY2VpbCh0aGlzWydyZSddICogcGxhY2VzKSAvIHBsYWNlcyxcbiAgICAgIE1hdGguY2VpbCh0aGlzWydpbSddICogcGxhY2VzKSAvIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsb29ycyB0aGUgYWN0dWFsIGNvbXBsZXggbnVtYmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Zsb29yJzogZnVuY3Rpb24gKHBsYWNlcykge1xuXG4gICAgcGxhY2VzID0gTWF0aC5wb3coMTAsIHBsYWNlcyB8fCAwKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguZmxvb3IodGhpc1sncmUnXSAqIHBsYWNlcykgLyBwbGFjZXMsXG4gICAgICBNYXRoLmZsb29yKHRoaXNbJ2ltJ10gKiBwbGFjZXMpIC8gcGxhY2VzKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2VpbHMgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdyb3VuZCc6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblxuICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLnJvdW5kKHRoaXNbJ3JlJ10gKiBwbGFjZXMpIC8gcGxhY2VzLFxuICAgICAgTWF0aC5yb3VuZCh0aGlzWydpbSddICogcGxhY2VzKSAvIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICpcbiAgICogKipOb3RlOioqIG5ldyBDb21wbGV4KEluZmluaXR5KS5lcXVhbHMoSW5maW5pdHkpID09PSBmYWxzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICdlcXVhbHMnOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKHpbJ3JlJ10gLSB0aGlzWydyZSddKSA8PSBDb21wbGV4WydFUFNJTE9OJ10gJiZcbiAgICAgIE1hdGguYWJzKHpbJ2ltJ10gLSB0aGlzWydpbSddKSA8PSBDb21wbGV4WydFUFNJTE9OJ107XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgYWN0dWFsIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdjbG9uZSc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzWydyZSddLCB0aGlzWydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHN0cmluZyBvZiB0aGUgYWN0dWFsIGNvbXBsZXggbnVtYmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICAndG9TdHJpbmcnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBsZXQgYSA9IHRoaXNbJ3JlJ107XG4gICAgbGV0IGIgPSB0aGlzWydpbSddO1xuICAgIGxldCByZXQgPSBcIlwiO1xuXG4gICAgaWYgKHRoaXNbJ2lzTmFOJ10oKSkge1xuICAgICAgcmV0dXJuICdOYU4nO1xuICAgIH1cblxuICAgIGlmICh0aGlzWydpc0luZmluaXRlJ10oKSkge1xuICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGEpIDwgQ29tcGxleFsnRVBTSUxPTiddKSB7XG4gICAgICBhID0gMDtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoYikgPCBDb21wbGV4WydFUFNJTE9OJ10pIHtcbiAgICAgIGIgPSAwO1xuICAgIH1cblxuICAgIC8vIElmIGlzIHJlYWwgbnVtYmVyXG4gICAgaWYgKGIgPT09IDApIHtcbiAgICAgIHJldHVybiByZXQgKyBhO1xuICAgIH1cblxuICAgIGlmIChhICE9PSAwKSB7XG4gICAgICByZXQgKz0gYTtcbiAgICAgIHJldCArPSBcIiBcIjtcbiAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICBiID0gLWI7XG4gICAgICAgIHJldCArPSBcIi1cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCArPSBcIitcIjtcbiAgICAgIH1cbiAgICAgIHJldCArPSBcIiBcIjtcbiAgICB9IGVsc2UgaWYgKGIgPCAwKSB7XG4gICAgICBiID0gLWI7XG4gICAgICByZXQgKz0gXCItXCI7XG4gICAgfVxuXG4gICAgaWYgKDEgIT09IGIpIHsgLy8gYiBpcyB0aGUgYWJzb2x1dGUgaW1hZ2luYXJ5IHBhcnRcbiAgICAgIHJldCArPSBiO1xuICAgIH1cbiAgICByZXR1cm4gcmV0ICsgXCJpXCI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCBudW1iZXIgYXMgYSB2ZWN0b3JcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgJ3RvVmVjdG9yJzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIFt0aGlzWydyZSddLCB0aGlzWydpbSddXTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIHJlYWwgdmFsdWUgb2YgdGhlIGN1cnJlbnQgb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cbiAgICovXG4gICd2YWx1ZU9mJzogZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXNbJ2ltJ10gPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzWydyZSddO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgY29tcGxleCBudW1iZXIgaXMgbm90IG9uIHRoZSBSaWVtYW5uIHNwaGVyZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAnaXNOYU4nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXNbJ3JlJ10pIHx8IGlzTmFOKHRoaXNbJ2ltJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgY29tcGxleCBudW1iZXIgaXMgYXQgdGhlIHplcm8gcG9sZSBvZiB0aGVcbiAgICogUmllbWFubiBzcGhlcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgJ2lzWmVybyc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1snaW0nXSA9PT0gMCAmJiB0aGlzWydyZSddID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBjb21wbGV4IG51bWJlciBpcyBub3QgYXQgdGhlIGluZmluaXR5IHBvbGUgb2YgdGhlXG4gICAqIFJpZW1hbm4gc3BoZXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICdpc0Zpbml0ZSc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNGaW5pdGUodGhpc1sncmUnXSkgJiYgaXNGaW5pdGUodGhpc1snaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgYSBjb21wbGV4IG51bWJlciBpcyBhdCB0aGUgaW5maW5pdHkgcG9sZSBvZiB0aGVcbiAgICogUmllbWFubiBzcGhlcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgJ2lzSW5maW5pdGUnOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzWydpc0Zpbml0ZSddKCk7XG4gIH1cbn07XG5cbkNvbXBsZXhbJ1pFUk8nXSA9IG5ldyBDb21wbGV4KDAsIDApO1xuQ29tcGxleFsnT05FJ10gPSBuZXcgQ29tcGxleCgxLCAwKTtcbkNvbXBsZXhbJ0knXSA9IG5ldyBDb21wbGV4KDAsIDEpO1xuQ29tcGxleFsnUEknXSA9IG5ldyBDb21wbGV4KE1hdGguUEksIDApO1xuQ29tcGxleFsnRSddID0gbmV3IENvbXBsZXgoTWF0aC5FLCAwKTtcbkNvbXBsZXhbJ0lORklOSVRZJ10gPSBuZXcgQ29tcGxleChJbmZpbml0eSwgSW5maW5pdHkpO1xuQ29tcGxleFsnTkFOJ10gPSBuZXcgQ29tcGxleChOYU4sIE5hTik7XG5Db21wbGV4WydFUFNJTE9OJ10gPSAxZS0xNTtcbmV4cG9ydCB7XG4gIENvbXBsZXggYXMgZGVmYXVsdCwgQ29tcGxleFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/complex.js/dist/complex.mjs\n");

/***/ })

};
;