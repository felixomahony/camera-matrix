"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fraction.js";
exports.ids = ["vendor-chunks/fraction.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/fraction.js/dist/fraction.mjs":
/*!****************************************************!*\
  !*** ./node_modules/fraction.js/dist/fraction.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   \"default\": () => (/* binding */ Fraction)\n/* harmony export */ });\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <numerator>, 1 => <denominator> ]\n * { n => <numerator>, d => <denominator> }\n *\n * Integer form\n * - Single integer value as BigInt or Number\n *\n * Double form\n * - Single double value as Number\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n * let f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n// Set Identity function to downgrade BigInt to Number if needed\nif (typeof BigInt === 'undefined') BigInt = function (n) { if (isNaN(n)) throw new Error(\"\"); return n; };\n\nconst C_ZERO = BigInt(0);\nconst C_ONE = BigInt(1);\nconst C_TWO = BigInt(2);\nconst C_FIVE = BigInt(5);\nconst C_TEN = BigInt(10);\n\n// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n// Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\nconst MAX_CYCLE_LEN = 2000;\n\n// Parsed data to avoid calling \"new\" all the time\nconst P = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE\n};\n\nfunction assign(n, s) {\n\n  try {\n    n = BigInt(n);\n  } catch (e) {\n    throw InvalidParameter();\n  }\n  return n * s;\n}\n\nfunction trunc(x) {\n  return typeof x === 'bigint' ? x : Math.floor(x);\n}\n\n// Creates a new Fraction internally without the need of the bulky constructor\nfunction newFraction(n, d) {\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  const f = Object.create(Fraction.prototype);\n  f[\"s\"] = n < C_ZERO ? -C_ONE : C_ONE;\n\n  n = n < C_ZERO ? -n : n;\n\n  const a = gcd(n, d);\n\n  f[\"n\"] = n / a;\n  f[\"d\"] = d / a;\n  return f;\n}\n\nfunction factorize(num) {\n\n  const factors = {};\n\n  let n = num;\n  let i = C_TWO;\n  let s = C_FIVE - C_ONE;\n\n  while (s <= n) {\n\n    while (n % i === C_ZERO) {\n      n /= i;\n      factors[i] = (factors[i] || C_ZERO) + C_ONE;\n    }\n    s += C_ONE + C_TWO * i++;\n  }\n\n  if (n !== num) {\n    if (n > 1)\n      factors[n] = (factors[n] || C_ZERO) + C_ONE;\n  } else {\n    factors[num] = (factors[num] || C_ZERO) + C_ONE;\n  }\n  return factors;\n}\n\nconst parse = function (p1, p2) {\n\n  let n = C_ZERO, d = C_ONE, s = C_ONE;\n\n  if (p1 === undefined || p1 === null) { // No argument\n    /* void */\n  } else if (p2 !== undefined) { // Two arguments\n\n    if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else if (isNaN(p1)) {\n      throw InvalidParameter();\n    } else if (p1 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      n = BigInt(p1);\n    }\n\n    if (typeof p2 === \"bigint\") {\n      d = p2;\n    } else if (isNaN(p2)) {\n      throw InvalidParameter();\n    } else if (p2 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      d = BigInt(p2);\n    }\n\n    s = n * d;\n\n  } else if (typeof p1 === \"object\") {\n    if (\"d\" in p1 && \"n\" in p1) {\n      n = BigInt(p1[\"n\"]);\n      d = BigInt(p1[\"d\"]);\n      if (\"s\" in p1)\n        n *= BigInt(p1[\"s\"]);\n    } else if (0 in p1) {\n      n = BigInt(p1[0]);\n      if (1 in p1)\n        d = BigInt(p1[1]);\n    } else if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else {\n      throw InvalidParameter();\n    }\n    s = n * d;\n  } else if (typeof p1 === \"number\") {\n\n    if (isNaN(p1)) {\n      throw InvalidParameter();\n    }\n\n    if (p1 < 0) {\n      s = -C_ONE;\n      p1 = -p1;\n    }\n\n    if (p1 % 1 === 0) {\n      n = BigInt(p1);\n    } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow\n\n      let z = 1;\n\n      let A = 0, B = 1;\n      let C = 1, D = 1;\n\n      let N = 10000000;\n\n      if (p1 >= 1) {\n        z = 10 ** Math.floor(1 + Math.log10(p1));\n        p1 /= z;\n      }\n\n      // Using Farey Sequences\n\n      while (B <= N && D <= N) {\n        let M = (A + C) / (B + D);\n\n        if (p1 === M) {\n          if (B + D <= N) {\n            n = A + C;\n            d = B + D;\n          } else if (D > B) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n          break;\n\n        } else {\n\n          if (p1 > M) {\n            A += C;\n            B += D;\n          } else {\n            C += A;\n            D += B;\n          }\n\n          if (B > N) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n        }\n      }\n      n = BigInt(n) * BigInt(z);\n      d = BigInt(d);\n    }\n\n  } else if (typeof p1 === \"string\") {\n\n    let ndx = 0;\n\n    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;\n\n    let match = p1.replace(/_/g, '').match(/\\d+|./g);\n\n    if (match === null)\n      throw InvalidParameter();\n\n    if (match[ndx] === '-') {// Check for minus sign at the beginning\n      s = -C_ONE;\n      ndx++;\n    } else if (match[ndx] === '+') {// Check for plus sign at the beginning\n      ndx++;\n    }\n\n    if (match.length === ndx + 1) { // Check if it's just a simple number \"1234\"\n      w = assign(match[ndx++], s);\n    } else if (match[ndx + 1] === '.' || match[ndx] === '.') { // Check if it's a decimal number\n\n      if (match[ndx] !== '.') { // Handle 0.5 and .5\n        v = assign(match[ndx++], s);\n      }\n      ndx++;\n\n      // Check for decimal places\n      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === \"'\" && match[ndx + 3] === \"'\") {\n        w = assign(match[ndx], s);\n        y = C_TEN ** BigInt(match[ndx].length);\n        ndx++;\n      }\n\n      // Check for repeating places\n      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === \"'\" && match[ndx + 2] === \"'\") {\n        x = assign(match[ndx + 1], s);\n        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;\n        ndx += 3;\n      }\n\n    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n      w = assign(match[ndx], s);\n      y = assign(match[ndx + 2], C_ONE);\n      ndx += 3;\n    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n      v = assign(match[ndx], s);\n      w = assign(match[ndx + 2], s);\n      y = assign(match[ndx + 4], C_ONE);\n      ndx += 5;\n    }\n\n    if (match.length <= ndx) { // Check for more tokens on the stack\n      d = y * z;\n      s = /* void */\n        n = x + d * v + z * w;\n    } else {\n      throw InvalidParameter();\n    }\n\n  } else if (typeof p1 === \"bigint\") {\n    n = p1;\n    s = p1;\n    d = C_ONE;\n  } else {\n    throw InvalidParameter();\n  }\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  P[\"s\"] = s < C_ZERO ? -C_ONE : C_ONE;\n  P[\"n\"] = n < C_ZERO ? -n : n;\n  P[\"d\"] = d < C_ZERO ? -d : d;\n};\n\nfunction modpow(b, e, m) {\n\n  let r = C_ONE;\n  for (; e > C_ZERO; b = (b * b) % m, e >>= C_ONE) {\n\n    if (e & C_ONE) {\n      r = (r * b) % m;\n    }\n  }\n  return r;\n}\n\nfunction cycleLen(n, d) {\n\n  for (; d % C_TWO === C_ZERO;\n    d /= C_TWO) {\n  }\n\n  for (; d % C_FIVE === C_ZERO;\n    d /= C_FIVE) {\n  }\n\n  if (d === C_ONE) // Catch non-cyclic numbers\n    return C_ZERO;\n\n  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n  // 10^(d-1) % d == 1\n  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n  // as we want to translate the numbers to strings.\n\n  let rem = C_TEN % d;\n  let t = 1;\n\n  for (; rem !== C_ONE; t++) {\n    rem = rem * C_TEN % d;\n\n    if (t > MAX_CYCLE_LEN)\n      return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n  }\n  return BigInt(t);\n}\n\nfunction cycleStart(n, d, len) {\n\n  let rem1 = C_ONE;\n  let rem2 = modpow(C_TEN, len, d);\n\n  for (let t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n    // Solve 10^s == 10^(s+t) (mod d)\n\n    if (rem1 === rem2)\n      return BigInt(t);\n\n    rem1 = rem1 * C_TEN % d;\n    rem2 = rem2 * C_TEN % d;\n  }\n  return 0;\n}\n\nfunction gcd(a, b) {\n\n  if (!a)\n    return b;\n  if (!b)\n    return a;\n\n  while (1) {\n    a %= b;\n    if (!a)\n      return b;\n    b %= a;\n    if (!b)\n      return a;\n  }\n}\n\n/**\n * Module constructor\n *\n * @constructor\n * @param {number|Fraction=} a\n * @param {number=} b\n */\nfunction Fraction(a, b) {\n\n  parse(a, b);\n\n  if (this instanceof Fraction) {\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  } else {\n    return newFraction(P['s'] * P['n'], P['d']);\n  }\n}\n\nvar DivisionByZero = function () { return new Error(\"Division by Zero\"); };\nvar InvalidParameter = function () { return new Error(\"Invalid argument\"); };\nvar NonIntegerParameter = function () { return new Error(\"Parameters must be integer\"); };\n\nFraction.prototype = {\n\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE,\n\n  /**\n   * Calculates the absolute value\n   *\n   * Ex: new Fraction(-4).abs() => 4\n   **/\n  \"abs\": function () {\n\n    return newFraction(this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Inverts the sign of the current fraction\n   *\n   * Ex: new Fraction(-4).neg() => 4\n   **/\n  \"neg\": function () {\n\n    return newFraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Adds two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n   **/\n  \"add\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Subtracts two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n   **/\n  \"sub\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Multiplies two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n   **/\n  \"mul\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Divides two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n   **/\n  \"div\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n      this[\"d\"] * P[\"n\"]\n    );\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * Ex: new Fraction(\"-17.(345)\").clone()\n   **/\n  \"clone\": function () {\n    return newFraction(this['s'] * this['n'], this['d']);\n  },\n\n  /**\n   * Calculates the modulo of two rational numbers - a more precise fmod\n   *\n   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n   * Ex: new Fraction(20, 10).mod().equals(0) ? \"is Integer\"\n   **/\n  \"mod\": function (a, b) {\n\n    if (a === undefined) {\n      return newFraction(this[\"s\"] * this[\"n\"] % this[\"d\"], C_ONE);\n    }\n\n    parse(a, b);\n    if (C_ZERO === P[\"n\"] * this[\"d\"]) {\n      throw DivisionByZero();\n    }\n\n    /*\n     * First silly attempt, kinda slow\n     *\n     return that[\"sub\"]({\n     \"n\": num[\"n\"] * Math.floor((this.n / this.d) / (num.n / num.d)),\n     \"d\": num[\"d\"],\n     \"s\": this[\"s\"]\n     });*/\n\n    /*\n     * New attempt: a1 / b1 = a2 / b2 * q + r\n     * => b2 * a1 = a2 * b1 * q + b1 * b2 * r\n     * => (b2 * a1 % a2 * b1) / (b1 * b2)\n     */\n    return newFraction(\n      this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n      P[\"d\"] * this[\"d\"]\n    );\n  },\n\n  /**\n   * Calculates the fractional gcd of two rational numbers\n   *\n   * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n   */\n  \"gcd\": function (a, b) {\n\n    parse(a, b);\n\n    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n    return newFraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional lcm of two rational numbers\n   *\n   * Ex: new Fraction(5,8).lcm(3,7) => 15\n   */\n  \"lcm\": function (a, b) {\n\n    parse(a, b);\n\n    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n    if (P[\"n\"] === C_ZERO && this[\"n\"] === C_ZERO) {\n      return newFraction(C_ZERO, C_ONE);\n    }\n    return newFraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n  },\n\n  /**\n   * Gets the inverse of the fraction, means numerator and denominator are exchanged\n   *\n   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n   **/\n  \"inverse\": function () {\n    return newFraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n  },\n\n  /**\n   * Calculates the fraction to some integer exponent\n   *\n   * Ex: new Fraction(-1,2).pow(-3) => -8\n   */\n  \"pow\": function (a, b) {\n\n    parse(a, b);\n\n    // Trivial case when exp is an integer\n\n    if (P['d'] === C_ONE) {\n\n      if (P['s'] < C_ZERO) {\n        return newFraction((this['s'] * this[\"d\"]) ** P['n'], this[\"n\"] ** P['n']);\n      } else {\n        return newFraction((this['s'] * this[\"n\"]) ** P['n'], this[\"d\"] ** P['n']);\n      }\n    }\n\n    // Negative roots become complex\n    //     (-a/b)^(c/d) = x\n    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula\n    // From which follows that only for c=0 the root is non-complex\n    if (this['s'] < C_ZERO) return null;\n\n    // Now prime factor n and d\n    let N = factorize(this['n']);\n    let D = factorize(this['d']);\n\n    // Exponentiate and take root for n and d individually\n    let n = C_ONE;\n    let d = C_ONE;\n    for (let k in N) {\n      if (k === '1') continue;\n      if (k === '0') {\n        n = C_ZERO;\n        break;\n      }\n      N[k] *= P['n'];\n\n      if (N[k] % P['d'] === C_ZERO) {\n        N[k] /= P['d'];\n      } else return null;\n      n *= BigInt(k) ** N[k];\n    }\n\n    for (let k in D) {\n      if (k === '1') continue;\n      D[k] *= P['n'];\n\n      if (D[k] % P['d'] === C_ZERO) {\n        D[k] /= P['d'];\n      } else return null;\n      d *= BigInt(k) ** D[k];\n    }\n\n    if (P['s'] < C_ZERO) {\n      return newFraction(d, n);\n    }\n    return newFraction(n, d);\n  },\n\n  /**\n   * Calculates the logarithm of a fraction to a given rational base\n   *\n   * Ex: new Fraction(27, 8).log(9, 4) => 3/2\n   */\n  \"log\": function (a, b) {\n\n    parse(a, b);\n\n    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;\n\n    const allPrimes = {};\n\n    const baseFactors = factorize(P['n']);\n    const T1 = factorize(P['d']);\n\n    const numberFactors = factorize(this['n']);\n    const T2 = factorize(this['d']);\n\n    for (const prime in T1) {\n      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];\n    }\n    for (const prime in T2) {\n      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];\n    }\n\n    for (const prime in baseFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    for (const prime in numberFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n\n    let retN = null;\n    let retD = null;\n\n    // Iterate over all unique primes to determine if a consistent ratio exists\n    for (const prime in allPrimes) {\n\n      const baseExponent = baseFactors[prime] || C_ZERO;\n      const numberExponent = numberFactors[prime] || C_ZERO;\n\n      if (baseExponent === C_ZERO) {\n        if (numberExponent !== C_ZERO) {\n          return null; // Logarithm cannot be expressed as a rational number\n        }\n        continue; // Skip this prime since both exponents are zero\n      }\n\n      // Calculate the ratio of exponents for this prime\n      let curN = numberExponent;\n      let curD = baseExponent;\n\n      // Simplify the current ratio\n      const gcdValue = gcd(curN, curD);\n      curN /= gcdValue;\n      curD /= gcdValue;\n\n      // Check if this is the first ratio; otherwise, ensure ratios are consistent\n      if (retN === null && retD === null) {\n        retN = curN;\n        retD = curD;\n      } else if (curN * retD !== retN * curD) {\n        return null; // Ratios do not match, logarithm cannot be rational\n      }\n    }\n\n    return retN !== null && retD !== null\n      ? newFraction(retN, retD)\n      : null;\n  },\n\n  /**\n   * Check if two rational numbers are the same\n   *\n   * Ex: new Fraction(19.6).equals([98, 5]);\n   **/\n  \"equals\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] < P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] <= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] > P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] >= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Compare two rational numbers\n   * < 0 iff this < that\n   * > 0 iff this > that\n   * = 0 iff this = that\n   *\n   * Ex: new Fraction(19.6).compare([98, 5]);\n   **/\n  \"compare\": function (a, b) {\n\n    parse(a, b);\n    let t = this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"];\n\n    return (C_ZERO < t) - (t < C_ZERO);\n  },\n\n  /**\n   * Calculates the ceil of a rational number\n   *\n   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n   **/\n  \"ceil\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Calculates the floor of a rational number\n   *\n   * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n   **/\n  \"floor\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) -\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] < C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Rounds a rational numbers\n   *\n   * Ex: new Fraction('4.(3)').round() => (4 / 1)\n   **/\n  \"round\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    /* Derivation:\n\n    s >= 0:\n      round(n / d) = trunc(n / d) + (n % d) / d >= 0.5 ? 1 : 0\n                   = trunc(n / d) + 2(n % d) >= d ? 1 : 0\n    s < 0:\n      round(n / d) =-trunc(n / d) - (n % d) / d > 0.5 ? 1 : 0\n                   =-trunc(n / d) - 2(n % d) > d ? 1 : 0\n\n    =>:\n\n    round(s * n / d) = s * trunc(n / d) + s * (C + 2(n % d) > d ? 1 : 0)\n        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.\n    */\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      this[\"s\"] * ((this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[\"n\"] % this[\"d\"]) > this[\"d\"] ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n    * Rounds a rational number to a multiple of another rational number\n    *\n    * Ex: new Fraction('0.9').roundTo(\"1/8\") => 7 / 8\n    **/\n  \"roundTo\": function (a, b) {\n\n    /*\n    k * x/y ≤ a/b < (k+1) * x/y\n    ⇔ k ≤ a/b / (x/y) < (k+1)\n    ⇔ k = floor(a/b * y/x)\n    ⇔ k = floor((a * y) / (b * x))\n    */\n\n    parse(a, b);\n\n    const n = this['n'] * P['d'];\n    const d = this['d'] * P['n'];\n    const r = n % d;\n\n    // round(n / d) = trunc(n / d) + 2(n % d) >= d ? 1 : 0\n    let k = trunc(n / d);\n    if (r + r >= d) {\n      k++;\n    }\n    return newFraction(this['s'] * k * P['n'], P['d']);\n  },\n\n  /**\n   * Check if two rational numbers are divisible\n   *\n   * Ex: new Fraction(19.6).divisible(1.5);\n   */\n  \"divisible\": function (a, b) {\n\n    parse(a, b);\n    return !(!(P[\"n\"] * this[\"d\"]) || ((this[\"n\"] * P[\"d\"]) % (P[\"n\"] * this[\"d\"])));\n  },\n\n  /**\n   * Returns a decimal representation of the fraction\n   *\n   * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n   **/\n  'valueOf': function () {\n    // Best we can do so far\n    return Number(this[\"s\"] * this[\"n\"]) / Number(this[\"d\"]);\n  },\n\n  /**\n   * Creates a string representation of a fraction with all digits\n   *\n   * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n   **/\n  'toString': function (dec) {\n\n    let N = this[\"n\"];\n    let D = this[\"d\"];\n\n    dec = dec || 15; // 15 = decimal places when no repetition\n\n    let cycLen = cycleLen(N, D); // Cycle length\n    let cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    // Append integer part\n    str += trunc(N / D);\n\n    N %= D;\n    N *= C_TEN;\n\n    if (N)\n      str += \".\";\n\n    if (cycLen) {\n\n      for (let i = cycOff; i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \"(\";\n      for (let i = cycLen; i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \")\";\n    } else {\n      for (let i = dec; N && i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n    }\n    return str;\n  },\n\n  /**\n   * Returns a string-fraction representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n   **/\n  'toFraction': function (showMixed) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      let whole = trunc(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        str += \" \";\n        n %= d;\n      }\n\n      str += n;\n      str += '/';\n      str += d;\n    }\n    return str;\n  },\n\n  /**\n   * Returns a latex representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n   **/\n  'toLatex': function (showMixed) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      let whole = trunc(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        n %= d;\n      }\n\n      str += \"\\\\frac{\";\n      str += n;\n      str += '}{';\n      str += d;\n      str += '}';\n    }\n    return str;\n  },\n\n  /**\n   * Returns an array of continued fraction elements\n   *\n   * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n   */\n  'toContinued': function () {\n\n    let a = this['n'];\n    let b = this['d'];\n    let res = [];\n\n    do {\n      res.push(trunc(a / b));\n      let t = a % b;\n      a = b;\n      b = t;\n    } while (a !== C_ONE);\n\n    return res;\n  },\n\n  \"simplify\": function (eps) {\n\n    const ieps = BigInt(1 / (eps || 0.001) | 0);\n\n    const thisABS = this['abs']();\n    const cont = thisABS['toContinued']();\n\n    for (let i = 1; i < cont.length; i++) {\n\n      let s = newFraction(cont[i - 1], C_ONE);\n      for (let k = i - 2; k >= 0; k--) {\n        s = s['inverse']()['add'](cont[k]);\n      }\n\n      let t = s['sub'](thisABS);\n      if (t['n'] * ieps < t['d']) { // More robust than Math.abs(t.valueOf()) < eps\n        return s['mul'](this['s']);\n      }\n    }\n    return this;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZGlzdC9mcmFjdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELG1DQUFtQzs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQSxJQUFJLDZCQUE2Qjs7QUFFakM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sbUJBQW1COztBQUV6Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsTUFBTSw4QkFBOEI7QUFDcEM7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSxNQUFNLHlEQUF5RDs7QUFFL0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLFlBQVk7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxlQUFlO0FBQ3hCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLE9BQU87QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sRUFBRTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCLGlDQUFpQztBQUNqQywyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRyxFQUFFO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQztBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mZWxpeG9tYWhvbnkvLi9ub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZGlzdC9mcmFjdGlvbi5tanM/YmJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3Mgb2ZmZXJzIHRoZSBwb3NzaWJpbGl0eSB0byBjYWxjdWxhdGUgZnJhY3Rpb25zLlxuICogWW91IGNhbiBwYXNzIGEgZnJhY3Rpb24gaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBhcnJheSwgYXMgZG91YmxlLCBhcyBzdHJpbmcgb3IgYXMgYW4gaW50ZWdlci5cbiAqXG4gKiBBcnJheS9PYmplY3QgZm9ybVxuICogWyAwID0+IDxudW1lcmF0b3I+LCAxID0+IDxkZW5vbWluYXRvcj4gXVxuICogeyBuID0+IDxudW1lcmF0b3I+LCBkID0+IDxkZW5vbWluYXRvcj4gfVxuICpcbiAqIEludGVnZXIgZm9ybVxuICogLSBTaW5nbGUgaW50ZWdlciB2YWx1ZSBhcyBCaWdJbnQgb3IgTnVtYmVyXG4gKlxuICogRG91YmxlIGZvcm1cbiAqIC0gU2luZ2xlIGRvdWJsZSB2YWx1ZSBhcyBOdW1iZXJcbiAqXG4gKiBTdHJpbmcgZm9ybVxuICogMTIzLjQ1NiAtIGEgc2ltcGxlIGRvdWJsZVxuICogMTIzLzQ1NiAtIGEgc3RyaW5nIGZyYWN0aW9uXG4gKiAxMjMuJzQ1NicgLSBhIGRvdWJsZSB3aXRoIHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlc1xuICogMTIzLig0NTYpIC0gc3lub255bVxuICogMTIzLjQ1JzYnIC0gYSBkb3VibGUgd2l0aCByZXBlYXRpbmcgbGFzdCBwbGFjZVxuICogMTIzLjQ1KDYpIC0gc3lub255bVxuICpcbiAqIEV4YW1wbGU6XG4gKiBsZXQgZiA9IG5ldyBGcmFjdGlvbihcIjkuNCczMSdcIik7XG4gKiBmLm11bChbLTQsIDNdKS5kaXYoNC45KTtcbiAqXG4gKi9cblxuLy8gU2V0IElkZW50aXR5IGZ1bmN0aW9uIHRvIGRvd25ncmFkZSBCaWdJbnQgdG8gTnVtYmVyIGlmIG5lZWRlZFxuaWYgKHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnKSBCaWdJbnQgPSBmdW5jdGlvbiAobikgeyBpZiAoaXNOYU4obikpIHRocm93IG5ldyBFcnJvcihcIlwiKTsgcmV0dXJuIG47IH07XG5cbmNvbnN0IENfWkVSTyA9IEJpZ0ludCgwKTtcbmNvbnN0IENfT05FID0gQmlnSW50KDEpO1xuY29uc3QgQ19UV08gPSBCaWdJbnQoMik7XG5jb25zdCBDX0ZJVkUgPSBCaWdJbnQoNSk7XG5jb25zdCBDX1RFTiA9IEJpZ0ludCgxMCk7XG5cbi8vIE1heGltdW0gc2VhcmNoIGRlcHRoIGZvciBjeWNsaWMgcmF0aW9uYWwgbnVtYmVycy4gMjAwMCBzaG91bGQgYmUgbW9yZSB0aGFuIGVub3VnaC5cbi8vIEV4YW1wbGU6IDEvNyA9IDAuKDE0Mjg1NykgaGFzIDYgcmVwZWF0aW5nIGRlY2ltYWwgcGxhY2VzLlxuLy8gSWYgTUFYX0NZQ0xFX0xFTiBnZXRzIHJlZHVjZWQsIGxvbmcgY3ljbGVzIHdpbGwgbm90IGJlIGRldGVjdGVkIGFuZCB0b1N0cmluZygpIG9ubHkgZ2V0cyB0aGUgZmlyc3QgMTAgZGlnaXRzXG5jb25zdCBNQVhfQ1lDTEVfTEVOID0gMjAwMDtcblxuLy8gUGFyc2VkIGRhdGEgdG8gYXZvaWQgY2FsbGluZyBcIm5ld1wiIGFsbCB0aGUgdGltZVxuY29uc3QgUCA9IHtcbiAgXCJzXCI6IENfT05FLFxuICBcIm5cIjogQ19aRVJPLFxuICBcImRcIjogQ19PTkVcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbihuLCBzKSB7XG5cbiAgdHJ5IHtcbiAgICBuID0gQmlnSW50KG4pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICB9XG4gIHJldHVybiBuICogcztcbn1cblxuZnVuY3Rpb24gdHJ1bmMoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdiaWdpbnQnID8geCA6IE1hdGguZmxvb3IoeCk7XG59XG5cbi8vIENyZWF0ZXMgYSBuZXcgRnJhY3Rpb24gaW50ZXJuYWxseSB3aXRob3V0IHRoZSBuZWVkIG9mIHRoZSBidWxreSBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gbmV3RnJhY3Rpb24obiwgZCkge1xuXG4gIGlmIChkID09PSBDX1pFUk8pIHtcbiAgICB0aHJvdyBEaXZpc2lvbkJ5WmVybygpO1xuICB9XG5cbiAgY29uc3QgZiA9IE9iamVjdC5jcmVhdGUoRnJhY3Rpb24ucHJvdG90eXBlKTtcbiAgZltcInNcIl0gPSBuIDwgQ19aRVJPID8gLUNfT05FIDogQ19PTkU7XG5cbiAgbiA9IG4gPCBDX1pFUk8gPyAtbiA6IG47XG5cbiAgY29uc3QgYSA9IGdjZChuLCBkKTtcblxuICBmW1wiblwiXSA9IG4gLyBhO1xuICBmW1wiZFwiXSA9IGQgLyBhO1xuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gZmFjdG9yaXplKG51bSkge1xuXG4gIGNvbnN0IGZhY3RvcnMgPSB7fTtcblxuICBsZXQgbiA9IG51bTtcbiAgbGV0IGkgPSBDX1RXTztcbiAgbGV0IHMgPSBDX0ZJVkUgLSBDX09ORTtcblxuICB3aGlsZSAocyA8PSBuKSB7XG5cbiAgICB3aGlsZSAobiAlIGkgPT09IENfWkVSTykge1xuICAgICAgbiAvPSBpO1xuICAgICAgZmFjdG9yc1tpXSA9IChmYWN0b3JzW2ldIHx8IENfWkVSTykgKyBDX09ORTtcbiAgICB9XG4gICAgcyArPSBDX09ORSArIENfVFdPICogaSsrO1xuICB9XG5cbiAgaWYgKG4gIT09IG51bSkge1xuICAgIGlmIChuID4gMSlcbiAgICAgIGZhY3RvcnNbbl0gPSAoZmFjdG9yc1tuXSB8fCBDX1pFUk8pICsgQ19PTkU7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yc1tudW1dID0gKGZhY3RvcnNbbnVtXSB8fCBDX1pFUk8pICsgQ19PTkU7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnM7XG59XG5cbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKHAxLCBwMikge1xuXG4gIGxldCBuID0gQ19aRVJPLCBkID0gQ19PTkUsIHMgPSBDX09ORTtcblxuICBpZiAocDEgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gbnVsbCkgeyAvLyBObyBhcmd1bWVudFxuICAgIC8qIHZvaWQgKi9cbiAgfSBlbHNlIGlmIChwMiAhPT0gdW5kZWZpbmVkKSB7IC8vIFR3byBhcmd1bWVudHNcblxuICAgIGlmICh0eXBlb2YgcDEgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIG4gPSBwMTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHAxKSkge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH0gZWxzZSBpZiAocDEgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBOb25JbnRlZ2VyUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBCaWdJbnQocDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcDIgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGQgPSBwMjtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHAyKSkge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH0gZWxzZSBpZiAocDIgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBOb25JbnRlZ2VyUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBCaWdJbnQocDIpO1xuICAgIH1cblxuICAgIHMgPSBuICogZDtcblxuICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChcImRcIiBpbiBwMSAmJiBcIm5cIiBpbiBwMSkge1xuICAgICAgbiA9IEJpZ0ludChwMVtcIm5cIl0pO1xuICAgICAgZCA9IEJpZ0ludChwMVtcImRcIl0pO1xuICAgICAgaWYgKFwic1wiIGluIHAxKVxuICAgICAgICBuICo9IEJpZ0ludChwMVtcInNcIl0pO1xuICAgIH0gZWxzZSBpZiAoMCBpbiBwMSkge1xuICAgICAgbiA9IEJpZ0ludChwMVswXSk7XG4gICAgICBpZiAoMSBpbiBwMSlcbiAgICAgICAgZCA9IEJpZ0ludChwMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcDEgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIG4gPSBwMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH1cbiAgICBzID0gbiAqIGQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcIm51bWJlclwiKSB7XG5cbiAgICBpZiAoaXNOYU4ocDEpKSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHAxIDwgMCkge1xuICAgICAgcyA9IC1DX09ORTtcbiAgICAgIHAxID0gLXAxO1xuICAgIH1cblxuICAgIGlmIChwMSAlIDEgPT09IDApIHtcbiAgICAgIG4gPSBCaWdJbnQocDEpO1xuICAgIH0gZWxzZSBpZiAocDEgPiAwKSB7IC8vIGNoZWNrIGZvciAhPSAwLCBzY2FsZSB3b3VsZCBiZWNvbWUgTmFOIChsb2coMCkpLCB3aGljaCBjb252ZXJnZXMgcmVhbGx5IHNsb3dcblxuICAgICAgbGV0IHogPSAxO1xuXG4gICAgICBsZXQgQSA9IDAsIEIgPSAxO1xuICAgICAgbGV0IEMgPSAxLCBEID0gMTtcblxuICAgICAgbGV0IE4gPSAxMDAwMDAwMDtcblxuICAgICAgaWYgKHAxID49IDEpIHtcbiAgICAgICAgeiA9IDEwICoqIE1hdGguZmxvb3IoMSArIE1hdGgubG9nMTAocDEpKTtcbiAgICAgICAgcDEgLz0gejtcbiAgICAgIH1cblxuICAgICAgLy8gVXNpbmcgRmFyZXkgU2VxdWVuY2VzXG5cbiAgICAgIHdoaWxlIChCIDw9IE4gJiYgRCA8PSBOKSB7XG4gICAgICAgIGxldCBNID0gKEEgKyBDKSAvIChCICsgRCk7XG5cbiAgICAgICAgaWYgKHAxID09PSBNKSB7XG4gICAgICAgICAgaWYgKEIgKyBEIDw9IE4pIHtcbiAgICAgICAgICAgIG4gPSBBICsgQztcbiAgICAgICAgICAgIGQgPSBCICsgRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKEQgPiBCKSB7XG4gICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKHAxID4gTSkge1xuICAgICAgICAgICAgQSArPSBDO1xuICAgICAgICAgICAgQiArPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDICs9IEE7XG4gICAgICAgICAgICBEICs9IEI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEIgPiBOKSB7XG4gICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbiA9IEJpZ0ludChuKSAqIEJpZ0ludCh6KTtcbiAgICAgIGQgPSBCaWdJbnQoZCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICBsZXQgbmR4ID0gMDtcblxuICAgIGxldCB2ID0gQ19aRVJPLCB3ID0gQ19aRVJPLCB4ID0gQ19aRVJPLCB5ID0gQ19PTkUsIHogPSBDX09ORTtcblxuICAgIGxldCBtYXRjaCA9IHAxLnJlcGxhY2UoL18vZywgJycpLm1hdGNoKC9cXGQrfC4vZyk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG5cbiAgICBpZiAobWF0Y2hbbmR4XSA9PT0gJy0nKSB7Ly8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgcyA9IC1DX09ORTtcbiAgICAgIG5keCsrO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbbmR4XSA9PT0gJysnKSB7Ly8gQ2hlY2sgZm9yIHBsdXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICBuZHgrKztcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gubGVuZ3RoID09PSBuZHggKyAxKSB7IC8vIENoZWNrIGlmIGl0J3MganVzdCBhIHNpbXBsZSBudW1iZXIgXCIxMjM0XCJcbiAgICAgIHcgPSBhc3NpZ24obWF0Y2hbbmR4KytdLCBzKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoW25keCArIDFdID09PSAnLicgfHwgbWF0Y2hbbmR4XSA9PT0gJy4nKSB7IC8vIENoZWNrIGlmIGl0J3MgYSBkZWNpbWFsIG51bWJlclxuXG4gICAgICBpZiAobWF0Y2hbbmR4XSAhPT0gJy4nKSB7IC8vIEhhbmRsZSAwLjUgYW5kIC41XG4gICAgICAgIHYgPSBhc3NpZ24obWF0Y2hbbmR4KytdLCBzKTtcbiAgICAgIH1cbiAgICAgIG5keCsrO1xuXG4gICAgICAvLyBDaGVjayBmb3IgZGVjaW1hbCBwbGFjZXNcbiAgICAgIGlmIChuZHggKyAxID09PSBtYXRjaC5sZW5ndGggfHwgbWF0Y2hbbmR4ICsgMV0gPT09ICcoJyAmJiBtYXRjaFtuZHggKyAzXSA9PT0gJyknIHx8IG1hdGNoW25keCArIDFdID09PSBcIidcIiAmJiBtYXRjaFtuZHggKyAzXSA9PT0gXCInXCIpIHtcbiAgICAgICAgdyA9IGFzc2lnbihtYXRjaFtuZHhdLCBzKTtcbiAgICAgICAgeSA9IENfVEVOICoqIEJpZ0ludChtYXRjaFtuZHhdLmxlbmd0aCk7XG4gICAgICAgIG5keCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgcmVwZWF0aW5nIHBsYWNlc1xuICAgICAgaWYgKG1hdGNoW25keF0gPT09ICcoJyAmJiBtYXRjaFtuZHggKyAyXSA9PT0gJyknIHx8IG1hdGNoW25keF0gPT09IFwiJ1wiICYmIG1hdGNoW25keCArIDJdID09PSBcIidcIikge1xuICAgICAgICB4ID0gYXNzaWduKG1hdGNoW25keCArIDFdLCBzKTtcbiAgICAgICAgeiA9IENfVEVOICoqIEJpZ0ludChtYXRjaFtuZHggKyAxXS5sZW5ndGgpIC0gQ19PTkU7XG4gICAgICAgIG5keCArPSAzO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChtYXRjaFtuZHggKyAxXSA9PT0gJy8nIHx8IG1hdGNoW25keCArIDFdID09PSAnOicpIHsgLy8gQ2hlY2sgZm9yIGEgc2ltcGxlIGZyYWN0aW9uIFwiMTIzLzQ1NlwiIG9yIFwiMTIzOjQ1NlwiXG4gICAgICB3ID0gYXNzaWduKG1hdGNoW25keF0sIHMpO1xuICAgICAgeSA9IGFzc2lnbihtYXRjaFtuZHggKyAyXSwgQ19PTkUpO1xuICAgICAgbmR4ICs9IDM7XG4gICAgfSBlbHNlIGlmIChtYXRjaFtuZHggKyAzXSA9PT0gJy8nICYmIG1hdGNoW25keCArIDFdID09PSAnICcpIHsgLy8gQ2hlY2sgZm9yIGEgY29tcGxleCBmcmFjdGlvbiBcIjEyMyAxLzJcIlxuICAgICAgdiA9IGFzc2lnbihtYXRjaFtuZHhdLCBzKTtcbiAgICAgIHcgPSBhc3NpZ24obWF0Y2hbbmR4ICsgMl0sIHMpO1xuICAgICAgeSA9IGFzc2lnbihtYXRjaFtuZHggKyA0XSwgQ19PTkUpO1xuICAgICAgbmR4ICs9IDU7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmxlbmd0aCA8PSBuZHgpIHsgLy8gQ2hlY2sgZm9yIG1vcmUgdG9rZW5zIG9uIHRoZSBzdGFja1xuICAgICAgZCA9IHkgKiB6O1xuICAgICAgcyA9IC8qIHZvaWQgKi9cbiAgICAgICAgbiA9IHggKyBkICogdiArIHogKiB3O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcImJpZ2ludFwiKSB7XG4gICAgbiA9IHAxO1xuICAgIHMgPSBwMTtcbiAgICBkID0gQ19PTkU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICB9XG5cbiAgaWYgKGQgPT09IENfWkVSTykge1xuICAgIHRocm93IERpdmlzaW9uQnlaZXJvKCk7XG4gIH1cblxuICBQW1wic1wiXSA9IHMgPCBDX1pFUk8gPyAtQ19PTkUgOiBDX09ORTtcbiAgUFtcIm5cIl0gPSBuIDwgQ19aRVJPID8gLW4gOiBuO1xuICBQW1wiZFwiXSA9IGQgPCBDX1pFUk8gPyAtZCA6IGQ7XG59O1xuXG5mdW5jdGlvbiBtb2Rwb3coYiwgZSwgbSkge1xuXG4gIGxldCByID0gQ19PTkU7XG4gIGZvciAoOyBlID4gQ19aRVJPOyBiID0gKGIgKiBiKSAlIG0sIGUgPj49IENfT05FKSB7XG5cbiAgICBpZiAoZSAmIENfT05FKSB7XG4gICAgICByID0gKHIgKiBiKSAlIG07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjeWNsZUxlbihuLCBkKSB7XG5cbiAgZm9yICg7IGQgJSBDX1RXTyA9PT0gQ19aRVJPO1xuICAgIGQgLz0gQ19UV08pIHtcbiAgfVxuXG4gIGZvciAoOyBkICUgQ19GSVZFID09PSBDX1pFUk87XG4gICAgZCAvPSBDX0ZJVkUpIHtcbiAgfVxuXG4gIGlmIChkID09PSBDX09ORSkgLy8gQ2F0Y2ggbm9uLWN5Y2xpYyBudW1iZXJzXG4gICAgcmV0dXJuIENfWkVSTztcblxuICAvLyBJZiB3ZSB3b3VsZCBsaWtlIHRvIGNvbXB1dGUgcmVhbGx5IGxhcmdlIG51bWJlcnMgcXVpY2tlciwgd2UgY291bGQgbWFrZSB1c2Ugb2YgRmVybWF0J3MgbGl0dGxlIHRoZW9yZW06XG4gIC8vIDEwXihkLTEpICUgZCA9PSAxXG4gIC8vIEhvd2V2ZXIsIHdlIGRvbid0IG5lZWQgc3VjaCBsYXJnZSBudW1iZXJzIGFuZCBNQVhfQ1lDTEVfTEVOIHNob3VsZCBiZSB0aGUgY2Fwc3RvbmUsXG4gIC8vIGFzIHdlIHdhbnQgdG8gdHJhbnNsYXRlIHRoZSBudW1iZXJzIHRvIHN0cmluZ3MuXG5cbiAgbGV0IHJlbSA9IENfVEVOICUgZDtcbiAgbGV0IHQgPSAxO1xuXG4gIGZvciAoOyByZW0gIT09IENfT05FOyB0KyspIHtcbiAgICByZW0gPSByZW0gKiBDX1RFTiAlIGQ7XG5cbiAgICBpZiAodCA+IE1BWF9DWUNMRV9MRU4pXG4gICAgICByZXR1cm4gQ19aRVJPOyAvLyBSZXR1cm5pbmcgMCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3QgcHJpbnQgaXQgYXMgYSBjeWNsaWMgbnVtYmVyLiBJdCdzIGxpa2VseSB0aGF0IHRoZSBhbnN3ZXIgaXMgYGQtMWBcbiAgfVxuICByZXR1cm4gQmlnSW50KHQpO1xufVxuXG5mdW5jdGlvbiBjeWNsZVN0YXJ0KG4sIGQsIGxlbikge1xuXG4gIGxldCByZW0xID0gQ19PTkU7XG4gIGxldCByZW0yID0gbW9kcG93KENfVEVOLCBsZW4sIGQpO1xuXG4gIGZvciAobGV0IHQgPSAwOyB0IDwgMzAwOyB0KyspIHsgLy8gcyA8IH5sb2cxMChOdW1iZXIuTUFYX1ZBTFVFKVxuICAgIC8vIFNvbHZlIDEwXnMgPT0gMTBeKHMrdCkgKG1vZCBkKVxuXG4gICAgaWYgKHJlbTEgPT09IHJlbTIpXG4gICAgICByZXR1cm4gQmlnSW50KHQpO1xuXG4gICAgcmVtMSA9IHJlbTEgKiBDX1RFTiAlIGQ7XG4gICAgcmVtMiA9IHJlbTIgKiBDX1RFTiAlIGQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGdjZChhLCBiKSB7XG5cbiAgaWYgKCFhKVxuICAgIHJldHVybiBiO1xuICBpZiAoIWIpXG4gICAgcmV0dXJuIGE7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICBhICU9IGI7XG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuIGI7XG4gICAgYiAlPSBhO1xuICAgIGlmICghYilcbiAgICAgIHJldHVybiBhO1xuICB9XG59XG5cbi8qKlxuICogTW9kdWxlIGNvbnN0cnVjdG9yXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnxGcmFjdGlvbj19IGFcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYlxuICovXG5mdW5jdGlvbiBGcmFjdGlvbihhLCBiKSB7XG5cbiAgcGFyc2UoYSwgYik7XG5cbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBGcmFjdGlvbikge1xuICAgIGEgPSBnY2QoUFtcImRcIl0sIFBbXCJuXCJdKTsgLy8gQWJ1c2UgYVxuICAgIHRoaXNbXCJzXCJdID0gUFtcInNcIl07XG4gICAgdGhpc1tcIm5cIl0gPSBQW1wiblwiXSAvIGE7XG4gICAgdGhpc1tcImRcIl0gPSBQW1wiZFwiXSAvIGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFBbJ3MnXSAqIFBbJ24nXSwgUFsnZCddKTtcbiAgfVxufVxuXG52YXIgRGl2aXNpb25CeVplcm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSBaZXJvXCIpOyB9O1xudmFyIEludmFsaWRQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpOyB9O1xudmFyIE5vbkludGVnZXJQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIG11c3QgYmUgaW50ZWdlclwiKTsgfTtcblxuRnJhY3Rpb24ucHJvdG90eXBlID0ge1xuXG4gIFwic1wiOiBDX09ORSxcbiAgXCJuXCI6IENfWkVSTyxcbiAgXCJkXCI6IENfT05FLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKC00KS5hYnMoKSA9PiA0XG4gICAqKi9cbiAgXCJhYnNcIjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbXCJuXCJdLCB0aGlzW1wiZFwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludmVydHMgdGhlIHNpZ24gb2YgdGhlIGN1cnJlbnQgZnJhY3Rpb25cbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigtNCkubmVnKCkgPT4gNFxuICAgKiovXG4gIFwibmVnXCI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbigtdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSwgdGhpc1tcImRcIl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IDQ2NyAvIDMwXG4gICAqKi9cbiAgXCJhZGRcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSArIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbih7bjogMiwgZDogM30pLmFkZChcIjE0LjlcIikgPT4gLTQyNyAvIDMwXG4gICAqKi9cbiAgXCJzdWJcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikubXVsKDMpID0+IDU3NzYgLyAxMTFcbiAgICoqL1xuICBcIm11bFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcIm5cIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogRGl2aWRlcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmludmVyc2UoKS5kaXYoMylcbiAgICoqL1xuICBcImRpdlwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJuXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikuY2xvbmUoKVxuICAgKiovXG4gIFwiY2xvbmVcIjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzWydzJ10gKiB0aGlzWyduJ10sIHRoaXNbJ2QnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsbyBvZiB0d28gcmF0aW9uYWwgbnVtYmVycyAtIGEgbW9yZSBwcmVjaXNlIGZtb2RcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5tb2QoWzcsIDhdKSA9PiAoMTMvMykgJSAoNy84KSA9ICg1LzYpXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMjAsIDEwKS5tb2QoKS5lcXVhbHMoMCkgPyBcImlzIEludGVnZXJcIlxuICAgKiovXG4gIFwibW9kXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdLCBDX09ORSk7XG4gICAgfVxuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgaWYgKENfWkVSTyA9PT0gUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkge1xuICAgICAgdGhyb3cgRGl2aXNpb25CeVplcm8oKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZpcnN0IHNpbGx5IGF0dGVtcHQsIGtpbmRhIHNsb3dcbiAgICAgKlxuICAgICByZXR1cm4gdGhhdFtcInN1YlwiXSh7XG4gICAgIFwiblwiOiBudW1bXCJuXCJdICogTWF0aC5mbG9vcigodGhpcy5uIC8gdGhpcy5kKSAvIChudW0ubiAvIG51bS5kKSksXG4gICAgIFwiZFwiOiBudW1bXCJkXCJdLFxuICAgICBcInNcIjogdGhpc1tcInNcIl1cbiAgICAgfSk7Ki9cblxuICAgIC8qXG4gICAgICogTmV3IGF0dGVtcHQ6IGExIC8gYjEgPSBhMiAvIGIyICogcSArIHJcbiAgICAgKiA9PiBiMiAqIGExID0gYTIgKiBiMSAqIHEgKyBiMSAqIGIyICogclxuICAgICAqID0+IChiMiAqIGExICUgYTIgKiBiMSkgLyAoYjEgKiBiMilcbiAgICAgKi9cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICB0aGlzW1wic1wiXSAqIChQW1wiZFwiXSAqIHRoaXNbXCJuXCJdKSAlIChQW1wiblwiXSAqIHRoaXNbXCJkXCJdKSxcbiAgICAgIFBbXCJkXCJdICogdGhpc1tcImRcIl1cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBmcmFjdGlvbmFsIGdjZCBvZiB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDUsOCkuZ2NkKDMsNykgPT4gMS81NlxuICAgKi9cbiAgXCJnY2RcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgLy8gZ2NkKGEgLyBiLCBjIC8gZCkgPSBnY2QoYSwgYykgLyBsY20oYiwgZClcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbihnY2QoUFtcIm5cIl0sIHRoaXNbXCJuXCJdKSAqIGdjZChQW1wiZFwiXSwgdGhpc1tcImRcIl0pLCBQW1wiZFwiXSAqIHRoaXNbXCJkXCJdKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb25hbCBsY20gb2YgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbig1LDgpLmxjbSgzLDcpID0+IDE1XG4gICAqL1xuICBcImxjbVwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICAvLyBsY20oYSAvIGIsIGMgLyBkKSA9IGxjbShhLCBjKSAvIGdjZChiLCBkKVxuXG4gICAgaWYgKFBbXCJuXCJdID09PSBDX1pFUk8gJiYgdGhpc1tcIm5cIl0gPT09IENfWkVSTykge1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKENfWkVSTywgQ19PTkUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oUFtcIm5cIl0gKiB0aGlzW1wiblwiXSwgZ2NkKFBbXCJuXCJdLCB0aGlzW1wiblwiXSkgKiBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGludmVyc2Ugb2YgdGhlIGZyYWN0aW9uLCBtZWFucyBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIGFyZSBleGNoYW5nZWRcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihbLTMsIDRdKS5pbnZlcnNlKCkgPT4gLTQgLyAzXG4gICAqKi9cbiAgXCJpbnZlcnNlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcInNcIl0gKiB0aGlzW1wiZFwiXSwgdGhpc1tcIm5cIl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBmcmFjdGlvbiB0byBzb21lIGludGVnZXIgZXhwb25lbnRcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigtMSwyKS5wb3coLTMpID0+IC04XG4gICAqL1xuICBcInBvd1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICAvLyBUcml2aWFsIGNhc2Ugd2hlbiBleHAgaXMgYW4gaW50ZWdlclxuXG4gICAgaWYgKFBbJ2QnXSA9PT0gQ19PTkUpIHtcblxuICAgICAgaWYgKFBbJ3MnXSA8IENfWkVSTykge1xuICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oKHRoaXNbJ3MnXSAqIHRoaXNbXCJkXCJdKSAqKiBQWyduJ10sIHRoaXNbXCJuXCJdICoqIFBbJ24nXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oKHRoaXNbJ3MnXSAqIHRoaXNbXCJuXCJdKSAqKiBQWyduJ10sIHRoaXNbXCJkXCJdICoqIFBbJ24nXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTmVnYXRpdmUgcm9vdHMgYmVjb21lIGNvbXBsZXhcbiAgICAvLyAgICAgKC1hL2IpXihjL2QpID0geFxuICAgIC8vIOKHlCAoLTEpXihjL2QpICogKGEvYileKGMvZCkgPSB4XG4gICAgLy8g4oeUIChjb3MocGkpICsgaSpzaW4ocGkpKV4oYy9kKSAqIChhL2IpXihjL2QpID0geFxuICAgIC8vIOKHlCAoY29zKGMqcGkvZCkgKyBpKnNpbihjKnBpL2QpKSAqIChhL2IpXihjL2QpID0geCAgICAgICAjIERlTW9pdnJlJ3MgZm9ybXVsYVxuICAgIC8vIEZyb20gd2hpY2ggZm9sbG93cyB0aGF0IG9ubHkgZm9yIGM9MCB0aGUgcm9vdCBpcyBub24tY29tcGxleFxuICAgIGlmICh0aGlzWydzJ10gPCBDX1pFUk8pIHJldHVybiBudWxsO1xuXG4gICAgLy8gTm93IHByaW1lIGZhY3RvciBuIGFuZCBkXG4gICAgbGV0IE4gPSBmYWN0b3JpemUodGhpc1snbiddKTtcbiAgICBsZXQgRCA9IGZhY3Rvcml6ZSh0aGlzWydkJ10pO1xuXG4gICAgLy8gRXhwb25lbnRpYXRlIGFuZCB0YWtlIHJvb3QgZm9yIG4gYW5kIGQgaW5kaXZpZHVhbGx5XG4gICAgbGV0IG4gPSBDX09ORTtcbiAgICBsZXQgZCA9IENfT05FO1xuICAgIGZvciAobGV0IGsgaW4gTikge1xuICAgICAgaWYgKGsgPT09ICcxJykgY29udGludWU7XG4gICAgICBpZiAoayA9PT0gJzAnKSB7XG4gICAgICAgIG4gPSBDX1pFUk87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgTltrXSAqPSBQWyduJ107XG5cbiAgICAgIGlmIChOW2tdICUgUFsnZCddID09PSBDX1pFUk8pIHtcbiAgICAgICAgTltrXSAvPSBQWydkJ107XG4gICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBuICo9IEJpZ0ludChrKSAqKiBOW2tdO1xuICAgIH1cblxuICAgIGZvciAobGV0IGsgaW4gRCkge1xuICAgICAgaWYgKGsgPT09ICcxJykgY29udGludWU7XG4gICAgICBEW2tdICo9IFBbJ24nXTtcblxuICAgICAgaWYgKERba10gJSBQWydkJ10gPT09IENfWkVSTykge1xuICAgICAgICBEW2tdIC89IFBbJ2QnXTtcbiAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgIGQgKj0gQmlnSW50KGspICoqIERba107XG4gICAgfVxuXG4gICAgaWYgKFBbJ3MnXSA8IENfWkVSTykge1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGQsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24obiwgZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxvZ2FyaXRobSBvZiBhIGZyYWN0aW9uIHRvIGEgZ2l2ZW4gcmF0aW9uYWwgYmFzZVxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDI3LCA4KS5sb2coOSwgNCkgPT4gMy8yXG4gICAqL1xuICBcImxvZ1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICBpZiAodGhpc1sncyddIDw9IENfWkVSTyB8fCBQWydzJ10gPD0gQ19aRVJPKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGFsbFByaW1lcyA9IHt9O1xuXG4gICAgY29uc3QgYmFzZUZhY3RvcnMgPSBmYWN0b3JpemUoUFsnbiddKTtcbiAgICBjb25zdCBUMSA9IGZhY3Rvcml6ZShQWydkJ10pO1xuXG4gICAgY29uc3QgbnVtYmVyRmFjdG9ycyA9IGZhY3Rvcml6ZSh0aGlzWyduJ10pO1xuICAgIGNvbnN0IFQyID0gZmFjdG9yaXplKHRoaXNbJ2QnXSk7XG5cbiAgICBmb3IgKGNvbnN0IHByaW1lIGluIFQxKSB7XG4gICAgICBiYXNlRmFjdG9yc1twcmltZV0gPSAoYmFzZUZhY3RvcnNbcHJpbWVdIHx8IENfWkVSTykgLSBUMVtwcmltZV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJpbWUgaW4gVDIpIHtcbiAgICAgIG51bWJlckZhY3RvcnNbcHJpbWVdID0gKG51bWJlckZhY3RvcnNbcHJpbWVdIHx8IENfWkVSTykgLSBUMltwcmltZV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBiYXNlRmFjdG9ycykge1xuICAgICAgaWYgKHByaW1lID09PSAnMScpIGNvbnRpbnVlO1xuICAgICAgYWxsUHJpbWVzW3ByaW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJpbWUgaW4gbnVtYmVyRmFjdG9ycykge1xuICAgICAgaWYgKHByaW1lID09PSAnMScpIGNvbnRpbnVlO1xuICAgICAgYWxsUHJpbWVzW3ByaW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHJldE4gPSBudWxsO1xuICAgIGxldCByZXREID0gbnVsbDtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgdW5pcXVlIHByaW1lcyB0byBkZXRlcm1pbmUgaWYgYSBjb25zaXN0ZW50IHJhdGlvIGV4aXN0c1xuICAgIGZvciAoY29uc3QgcHJpbWUgaW4gYWxsUHJpbWVzKSB7XG5cbiAgICAgIGNvbnN0IGJhc2VFeHBvbmVudCA9IGJhc2VGYWN0b3JzW3ByaW1lXSB8fCBDX1pFUk87XG4gICAgICBjb25zdCBudW1iZXJFeHBvbmVudCA9IG51bWJlckZhY3RvcnNbcHJpbWVdIHx8IENfWkVSTztcblxuICAgICAgaWYgKGJhc2VFeHBvbmVudCA9PT0gQ19aRVJPKSB7XG4gICAgICAgIGlmIChudW1iZXJFeHBvbmVudCAhPT0gQ19aRVJPKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7IC8vIExvZ2FyaXRobSBjYW5ub3QgYmUgZXhwcmVzc2VkIGFzIGEgcmF0aW9uYWwgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwcmltZSBzaW5jZSBib3RoIGV4cG9uZW50cyBhcmUgemVyb1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIGV4cG9uZW50cyBmb3IgdGhpcyBwcmltZVxuICAgICAgbGV0IGN1ck4gPSBudW1iZXJFeHBvbmVudDtcbiAgICAgIGxldCBjdXJEID0gYmFzZUV4cG9uZW50O1xuXG4gICAgICAvLyBTaW1wbGlmeSB0aGUgY3VycmVudCByYXRpb1xuICAgICAgY29uc3QgZ2NkVmFsdWUgPSBnY2QoY3VyTiwgY3VyRCk7XG4gICAgICBjdXJOIC89IGdjZFZhbHVlO1xuICAgICAgY3VyRCAvPSBnY2RWYWx1ZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZmlyc3QgcmF0aW87IG90aGVyd2lzZSwgZW5zdXJlIHJhdGlvcyBhcmUgY29uc2lzdGVudFxuICAgICAgaWYgKHJldE4gPT09IG51bGwgJiYgcmV0RCA9PT0gbnVsbCkge1xuICAgICAgICByZXROID0gY3VyTjtcbiAgICAgICAgcmV0RCA9IGN1ckQ7XG4gICAgICB9IGVsc2UgaWYgKGN1ck4gKiByZXREICE9PSByZXROICogY3VyRCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gUmF0aW9zIGRvIG5vdCBtYXRjaCwgbG9nYXJpdGhtIGNhbm5vdCBiZSByYXRpb25hbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXROICE9PSBudWxsICYmIHJldEQgIT09IG51bGxcbiAgICAgID8gbmV3RnJhY3Rpb24ocmV0TiwgcmV0RClcbiAgICAgIDogbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHJhdGlvbmFsIG51bWJlcnMgYXJlIHRoZSBzYW1lXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikuZXF1YWxzKFs5OCwgNV0pO1xuICAgKiovXG4gIFwiZXF1YWxzXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdID09PSBQW1wic1wiXSAqIFBbXCJuXCJdICogdGhpc1tcImRcIl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgcmF0aW9uYWwgbnVtYmVyIGlzIGxlc3MgdGhhbiBhbm90aGVyXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikubHQoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJsdFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA8IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImx0ZVwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA8PSBQW1wic1wiXSAqIFBbXCJuXCJdICogdGhpc1tcImRcIl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgcmF0aW9uYWwgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMTkuNikubHQoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJndFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA+IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImd0ZVwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSA+PSBQW1wic1wiXSAqIFBbXCJuXCJdICogdGhpc1tcImRcIl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICogPCAwIGlmZiB0aGlzIDwgdGhhdFxuICAgKiA+IDAgaWZmIHRoaXMgPiB0aGF0XG4gICAqID0gMCBpZmYgdGhpcyA9IHRoYXRcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5jb21wYXJlKFs5OCwgNV0pO1xuICAgKiovXG4gIFwiY29tcGFyZVwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgbGV0IHQgPSB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gLSBQW1wic1wiXSAqIFBbXCJuXCJdICogdGhpc1tcImRcIl07XG5cbiAgICByZXR1cm4gKENfWkVSTyA8IHQpIC0gKHQgPCBDX1pFUk8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjZWlsIG9mIGEgcmF0aW9uYWwgbnVtYmVyXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykuY2VpbCgpID0+ICg1IC8gMSlcbiAgICoqL1xuICBcImNlaWxcIjogZnVuY3Rpb24gKHBsYWNlcykge1xuXG4gICAgcGxhY2VzID0gQ19URU4gKiogQmlnSW50KHBsYWNlcyB8fCAwKTtcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbih0cnVuYyh0aGlzW1wic1wiXSAqIHBsYWNlcyAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pICtcbiAgICAgIChwbGFjZXMgKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdID4gQ19aRVJPICYmIHRoaXNbXCJzXCJdID49IENfWkVSTyA/IENfT05FIDogQ19aRVJPKSxcbiAgICAgIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZsb29yIG9mIGEgcmF0aW9uYWwgbnVtYmVyXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykuZmxvb3IoKSA9PiAoNCAvIDEpXG4gICAqKi9cbiAgXCJmbG9vclwiOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBDX1RFTiAqKiBCaWdJbnQocGxhY2VzIHx8IDApO1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRydW5jKHRoaXNbXCJzXCJdICogcGxhY2VzICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSkgLVxuICAgICAgKHBsYWNlcyAqIHRoaXNbXCJuXCJdICUgdGhpc1tcImRcIl0gPiBDX1pFUk8gJiYgdGhpc1tcInNcIl0gPCBDX1pFUk8gPyBDX09ORSA6IENfWkVSTyksXG4gICAgICBwbGFjZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSb3VuZHMgYSByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykucm91bmQoKSA9PiAoNCAvIDEpXG4gICAqKi9cbiAgXCJyb3VuZFwiOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBDX1RFTiAqKiBCaWdJbnQocGxhY2VzIHx8IDApO1xuXG4gICAgLyogRGVyaXZhdGlvbjpcblxuICAgIHMgPj0gMDpcbiAgICAgIHJvdW5kKG4gLyBkKSA9IHRydW5jKG4gLyBkKSArIChuICUgZCkgLyBkID49IDAuNSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgPSB0cnVuYyhuIC8gZCkgKyAyKG4gJSBkKSA+PSBkID8gMSA6IDBcbiAgICBzIDwgMDpcbiAgICAgIHJvdW5kKG4gLyBkKSA9LXRydW5jKG4gLyBkKSAtIChuICUgZCkgLyBkID4gMC41ID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICA9LXRydW5jKG4gLyBkKSAtIDIobiAlIGQpID4gZCA/IDEgOiAwXG5cbiAgICA9PjpcblxuICAgIHJvdW5kKHMgKiBuIC8gZCkgPSBzICogdHJ1bmMobiAvIGQpICsgcyAqIChDICsgMihuICUgZCkgPiBkID8gMSA6IDApXG4gICAgICAgIHdoZXJlIEMgPSBzID49IDAgPyAxIDogMCwgdG8gZml4IHRoZSA+PSBmb3IgdGhlIHBvc2l0dmUgY2FzZS5cbiAgICAqL1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRydW5jKHRoaXNbXCJzXCJdICogcGxhY2VzICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSkgK1xuICAgICAgdGhpc1tcInNcIl0gKiAoKHRoaXNbXCJzXCJdID49IENfWkVSTyA/IENfT05FIDogQ19aRVJPKSArIENfVFdPICogKHBsYWNlcyAqIHRoaXNbXCJuXCJdICUgdGhpc1tcImRcIl0pID4gdGhpc1tcImRcIl0gPyBDX09ORSA6IENfWkVSTyksXG4gICAgICBwbGFjZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgICogUm91bmRzIGEgcmF0aW9uYWwgbnVtYmVyIHRvIGEgbXVsdGlwbGUgb2YgYW5vdGhlciByYXRpb25hbCBudW1iZXJcbiAgICAqXG4gICAgKiBFeDogbmV3IEZyYWN0aW9uKCcwLjknKS5yb3VuZFRvKFwiMS84XCIpID0+IDcgLyA4XG4gICAgKiovXG4gIFwicm91bmRUb1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgLypcbiAgICBrICogeC95IOKJpCBhL2IgPCAoaysxKSAqIHgveVxuICAgIOKHlCBrIOKJpCBhL2IgLyAoeC95KSA8IChrKzEpXG4gICAg4oeUIGsgPSBmbG9vcihhL2IgKiB5L3gpXG4gICAg4oeUIGsgPSBmbG9vcigoYSAqIHkpIC8gKGIgKiB4KSlcbiAgICAqL1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICBjb25zdCBuID0gdGhpc1snbiddICogUFsnZCddO1xuICAgIGNvbnN0IGQgPSB0aGlzWydkJ10gKiBQWyduJ107XG4gICAgY29uc3QgciA9IG4gJSBkO1xuXG4gICAgLy8gcm91bmQobiAvIGQpID0gdHJ1bmMobiAvIGQpICsgMihuICUgZCkgPj0gZCA/IDEgOiAwXG4gICAgbGV0IGsgPSB0cnVuYyhuIC8gZCk7XG4gICAgaWYgKHIgKyByID49IGQpIHtcbiAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbJ3MnXSAqIGsgKiBQWyduJ10sIFBbJ2QnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byByYXRpb25hbCBudW1iZXJzIGFyZSBkaXZpc2libGVcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5kaXZpc2libGUoMS41KTtcbiAgICovXG4gIFwiZGl2aXNpYmxlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gISghKFBbXCJuXCJdICogdGhpc1tcImRcIl0pIHx8ICgodGhpc1tcIm5cIl0gKiBQW1wiZFwiXSkgJSAoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZyYWN0aW9uXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxMDAuJzkxODIzJ1wiKS52YWx1ZU9mKCkgPT4gMTAwLjkxODIzOTE4MjM5MTgzXG4gICAqKi9cbiAgJ3ZhbHVlT2YnOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmVzdCB3ZSBjYW4gZG8gc28gZmFyXG4gICAgcmV0dXJuIE51bWJlcih0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdKSAvIE51bWJlcih0aGlzW1wiZFwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmcmFjdGlvbiB3aXRoIGFsbCBkaWdpdHNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEwMC4nOTE4MjMnXCIpLnRvU3RyaW5nKCkgPT4gXCIxMDAuKDkxODIzKVwiXG4gICAqKi9cbiAgJ3RvU3RyaW5nJzogZnVuY3Rpb24gKGRlYykge1xuXG4gICAgbGV0IE4gPSB0aGlzW1wiblwiXTtcbiAgICBsZXQgRCA9IHRoaXNbXCJkXCJdO1xuXG4gICAgZGVjID0gZGVjIHx8IDE1OyAvLyAxNSA9IGRlY2ltYWwgcGxhY2VzIHdoZW4gbm8gcmVwZXRpdGlvblxuXG4gICAgbGV0IGN5Y0xlbiA9IGN5Y2xlTGVuKE4sIEQpOyAvLyBDeWNsZSBsZW5ndGhcbiAgICBsZXQgY3ljT2ZmID0gY3ljbGVTdGFydChOLCBELCBjeWNMZW4pOyAvLyBDeWNsZSBzdGFydFxuXG4gICAgbGV0IHN0ciA9IHRoaXNbJ3MnXSA8IENfWkVSTyA/IFwiLVwiIDogXCJcIjtcblxuICAgIC8vIEFwcGVuZCBpbnRlZ2VyIHBhcnRcbiAgICBzdHIgKz0gdHJ1bmMoTiAvIEQpO1xuXG4gICAgTiAlPSBEO1xuICAgIE4gKj0gQ19URU47XG5cbiAgICBpZiAoTilcbiAgICAgIHN0ciArPSBcIi5cIjtcblxuICAgIGlmIChjeWNMZW4pIHtcblxuICAgICAgZm9yIChsZXQgaSA9IGN5Y09mZjsgaS0tOykge1xuICAgICAgICBzdHIgKz0gdHJ1bmMoTiAvIEQpO1xuICAgICAgICBOICU9IEQ7XG4gICAgICAgIE4gKj0gQ19URU47XG4gICAgICB9XG4gICAgICBzdHIgKz0gXCIoXCI7XG4gICAgICBmb3IgKGxldCBpID0gY3ljTGVuOyBpLS07KSB7XG4gICAgICAgIHN0ciArPSB0cnVuYyhOIC8gRCk7XG4gICAgICAgIE4gJT0gRDtcbiAgICAgICAgTiAqPSBDX1RFTjtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBcIilcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGRlYzsgTiAmJiBpLS07KSB7XG4gICAgICAgIHN0ciArPSB0cnVuYyhOIC8gRCk7XG4gICAgICAgIE4gJT0gRDtcbiAgICAgICAgTiAqPSBDX1RFTjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZy1mcmFjdGlvbiByZXByZXNlbnRhdGlvbiBvZiBhIEZyYWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9GcmFjdGlvbigpID0+IFwiNCAxLzNcIlxuICAgKiovXG4gICd0b0ZyYWN0aW9uJzogZnVuY3Rpb24gKHNob3dNaXhlZCkge1xuXG4gICAgbGV0IG4gPSB0aGlzW1wiblwiXTtcbiAgICBsZXQgZCA9IHRoaXNbXCJkXCJdO1xuICAgIGxldCBzdHIgPSB0aGlzWydzJ10gPCBDX1pFUk8gPyBcIi1cIiA6IFwiXCI7XG5cbiAgICBpZiAoZCA9PT0gQ19PTkUpIHtcbiAgICAgIHN0ciArPSBuO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgd2hvbGUgPSB0cnVuYyhuIC8gZCk7XG4gICAgICBpZiAoc2hvd01peGVkICYmIHdob2xlID4gQ19aRVJPKSB7XG4gICAgICAgIHN0ciArPSB3aG9sZTtcbiAgICAgICAgc3RyICs9IFwiIFwiO1xuICAgICAgICBuICU9IGQ7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBuO1xuICAgICAgc3RyICs9ICcvJztcbiAgICAgIHN0ciArPSBkO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGF0ZXggcmVwcmVzZW50YXRpb24gb2YgYSBGcmFjdGlvbiBvYmplY3RcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEuJzMnXCIpLnRvTGF0ZXgoKSA9PiBcIlxcZnJhY3s0fXszfVwiXG4gICAqKi9cbiAgJ3RvTGF0ZXgnOiBmdW5jdGlvbiAoc2hvd01peGVkKSB7XG5cbiAgICBsZXQgbiA9IHRoaXNbXCJuXCJdO1xuICAgIGxldCBkID0gdGhpc1tcImRcIl07XG4gICAgbGV0IHN0ciA9IHRoaXNbJ3MnXSA8IENfWkVSTyA/IFwiLVwiIDogXCJcIjtcblxuICAgIGlmIChkID09PSBDX09ORSkge1xuICAgICAgc3RyICs9IG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB3aG9sZSA9IHRydW5jKG4gLyBkKTtcbiAgICAgIGlmIChzaG93TWl4ZWQgJiYgd2hvbGUgPiBDX1pFUk8pIHtcbiAgICAgICAgc3RyICs9IHdob2xlO1xuICAgICAgICBuICU9IGQ7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBcIlxcXFxmcmFje1wiO1xuICAgICAgc3RyICs9IG47XG4gICAgICBzdHIgKz0gJ317JztcbiAgICAgIHN0ciArPSBkO1xuICAgICAgc3RyICs9ICd9JztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjb250aW51ZWQgZnJhY3Rpb24gZWxlbWVudHNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjcvOFwiKS50b0NvbnRpbnVlZCgpID0+IFswLDEsN11cbiAgICovXG4gICd0b0NvbnRpbnVlZCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIGxldCBhID0gdGhpc1snbiddO1xuICAgIGxldCBiID0gdGhpc1snZCddO1xuICAgIGxldCByZXMgPSBbXTtcblxuICAgIGRvIHtcbiAgICAgIHJlcy5wdXNoKHRydW5jKGEgLyBiKSk7XG4gICAgICBsZXQgdCA9IGEgJSBiO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdDtcbiAgICB9IHdoaWxlIChhICE9PSBDX09ORSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIFwic2ltcGxpZnlcIjogZnVuY3Rpb24gKGVwcykge1xuXG4gICAgY29uc3QgaWVwcyA9IEJpZ0ludCgxIC8gKGVwcyB8fCAwLjAwMSkgfCAwKTtcblxuICAgIGNvbnN0IHRoaXNBQlMgPSB0aGlzWydhYnMnXSgpO1xuICAgIGNvbnN0IGNvbnQgPSB0aGlzQUJTWyd0b0NvbnRpbnVlZCddKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbnQubGVuZ3RoOyBpKyspIHtcblxuICAgICAgbGV0IHMgPSBuZXdGcmFjdGlvbihjb250W2kgLSAxXSwgQ19PTkUpO1xuICAgICAgZm9yIChsZXQgayA9IGkgLSAyOyBrID49IDA7IGstLSkge1xuICAgICAgICBzID0gc1snaW52ZXJzZSddKClbJ2FkZCddKGNvbnRba10pO1xuICAgICAgfVxuXG4gICAgICBsZXQgdCA9IHNbJ3N1YiddKHRoaXNBQlMpO1xuICAgICAgaWYgKHRbJ24nXSAqIGllcHMgPCB0WydkJ10pIHsgLy8gTW9yZSByb2J1c3QgdGhhbiBNYXRoLmFicyh0LnZhbHVlT2YoKSkgPCBlcHNcbiAgICAgICAgcmV0dXJuIHNbJ211bCddKHRoaXNbJ3MnXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgRnJhY3Rpb24gYXMgZGVmYXVsdCwgRnJhY3Rpb25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fraction.js/dist/fraction.mjs\n");

/***/ })

};
;